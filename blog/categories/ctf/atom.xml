<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ctf | 犬アイコンのみっきー]]></title>
  <link href="http://mzyy94.com/blog/categories/ctf/atom.xml" rel="self"/>
  <link href="http://mzyy94.com/"/>
  <updated>2015-04-15T00:53:43+09:00</updated>
  <id>http://mzyy94.com/</id>
  <author>
    <name><![CDATA[mzyy94]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ネットエージェント最終面接問題 Write-up その3]]></title>
    <link href="http://mzyy94.com/blog/2015/04/15/netagent-mondai7-9/"/>
    <updated>2015-04-15T00:01:21+09:00</updated>
    <id>http://mzyy94.com/blog/2015/04/15/netagent-mondai7-9</id>
    <content type="html"><![CDATA[<p>あのネットエージェントのいきなり最終面接問題を解いたのでWrite-upを書きました。</p>

<ul>
<li><a href="http://www.netagent.co.jp/recruit/newgraduates_2016.html">2016年度 新卒採用｜ネットエージェント株式会社</a></li>
</ul>


<p>これまでのmondaiはLinuxやOS Xがあれば解くことができていましたが、mondai7からはWindowsの実行ファイル形式やMicrosoft Officeドキュメントが登場したりと、そろそろWindowsがない環境には手厳しい問題となってきました。
なので、今回の記事に掲載のmondaiはすべて（<code>file</code>コマンドでのファイル情報調査以外）、Windows上での解法となっております。</p>

<p>昨日の<a href="/blog/2015/04/14/netagent-mondai5-6/">mondai6までの解法</a>に続いて本日はmondai7、mondai8、mondai9の解法を公開します。</p>

<!-- more -->


<h1>mondai7</h1>

<p>mondai7はnormal.exeというWIN/PE32実行ファイルを解析して答えを得る問題のようです。</p>

<pre><code class="sh">$ file normal.exe
normal.exe: PE32 executable for MS Windows (GUI) Intel 80386 32-bit
</code></pre>

<p>今回はIDA Pro(demo)を使って解析してみます。</p>

<p><img src="/blog/resources/images//normal-ida1.png" alt="normal-ida1.png" /></p>

<p>IDAに解析させて表示を見てみると、おもむろに正解を表示するらしい<em>aCorrectKeyIsS</em>がみつかります。
ここまで来る過程をアセンブリ表示で追っていくことにします。</p>

<p><img src="/blog/resources/images//normal-ida2.png" alt="normal-ida2.png" /></p>

<p><em>aCorrectKeyIsS</em>はsprintfで渡されるテンプレート文字列で、そこにコマンドライン引数が埋め込められるようにいなっているようです。
このことから、normal.exeにキー候補の文字列をコマンドライン引数として渡して実行し、なにか判定があり、それが正しい場合に<strong>Correct! KEY is : </strong>に続いてその文字列が表示されるようになっていることがわかります。</p>

<p><img src="/blog/resources/images//normal-ida3.png" alt="normal-ida3.png" /></p>

<p>すこし遡ってみると、キーが表示される部分のサブルーチンへ来る前に、なにやら条件分岐があります。
コマンドライン第一引数の文字長をstrlenでチェックし、0x0A(=10)と比較し、合致しない場合に<strong>Try Again!</strong>と表示する処理がみつかりました。
このことから、キーは10文字長であることがわかります。</p>

<p><img src="/blog/resources/images//normal-ida4.png" alt="normal-ida4.png" /></p>

<p>キーが表示される直前に行われる処理を見てみると、サブルーチン<em>sub_4011C0</em>を呼んだ戻り値が0の場合、<strong>Try Again!</strong>の表示をさせるようになっています。
<em>sub_4011C0</em>にはコマンドライン引数を渡しているので、この引数が何か特定の文字列と比較されていると推測できます。</p>

<p><img src="/blog/resources/images//normal-ida5.png" alt="normal-ida5.png" /></p>

<p>サブルーチン<em>sub_4011C0</em>のはじめの方では、ループインデックス（以下、i）を0にしたりと、forループの初期化が行われている様子がつかめます。このループの中の処理を見てみます。</p>

<p><img src="/blog/resources/images//normal-ida6.png" alt="normal-ida6.png" /></p>

<p>このforループでは、iが0x0A(=10)になるまでループが回れば1を、途中でbreakが発生すれば0をサブルーチン呼び出し元に返すような処理をしています。
途中でbreakが発生する条件は、ループ内で呼ばれる<em>sub_401170</em>の戻り値と謎の配列<em>dword_40C068</em>の比較が偽である場合となっています。
要するに、このループがi=10になるまで回らないと呼び出し元に0が返され、<strong>Try Again!</strong>が表示されるということです。</p>

<p>コマンドライン引数のi番目の文字が引数として渡されて呼び出されている<em>sub_401170</em>を見てみます。</p>

<p><img src="/blog/resources/images//normal-ida7.png" alt="normal-ida7.png" /></p>

<p><em>sub_401170</em>はサブルーチンの引数で与えられた文字（＝コマンドライン引数のi番目の文字）が、謎の文字列<strong>&#8220;efyTUwxqrY&#8230;&#8221;</strong>の中の何番目に出てくるかを、forループを回して一つずつチェックしているようです。そしてサブルーチンの戻り値として、謎の文字列の何番目に引数の文字が現れたかを呼び出し元に返しています。</p>

<p><img src="/blog/resources/images//normal-ida8.png" alt="normal-ida8.png" /></p>

<p>謎の配列<em>dword_40C068</em>の中身を見に行くと、unsignled long型の配列として、数値が格納されていました。
先のサブルーチン<em>sub_4011C0</em>のループ内では、コマンドライン引数のi番目の文字を<em>sub_401170</em>に渡し、謎の文字列の何番目に出現するかを取得し、その値とこの<em>dword_40C068</em>のi番目の数値を比較して、同じであればループを継続するという処理でした。</p>

<p>ここまでの調査を基にまとめると、このプログラムの処理は簡易的に以下のようになっていることがわかります。</p>

<ul>
<li>コマンドライン引数に与えられた文字列があり、</li>
<li>その文字列は10文字であり、</li>
<li>その文字列の1文字1文字が謎の文字列<strong>&#8220;efyTUwxqrY&#8230;&#8221;</strong>の何番目に位置するかを調べていて、</li>
<li>その位置がすべて謎の配列<em>dword_40C068</em>に定義されたもの同じであれば<strong>Correct! Key is :</strong>に続けて引数を表示する</li>
</ul>


<p>なので逆に考えると、謎の文字列の中の、謎の配列に定義されている場所の文字を抽出すればキーが見つかるということです。
パパッと以下のようなものを書いてキーを抽出します。</p>

<pre><code class="ruby">#!/usr/bin/env ruby

string = "efyTUwxqrYHEFmduCJAXQpgKLBnhiltINPGOoszkMDvcjabSZRVW"
indexes = [0x03, 0x24, 0x2b, 0x1b, 0x0f, 0x17, 0x2d, 0x25, 0x24, 0x0f]

key = ""

for i in indexes do
    key += string[i]
end

p key
</code></pre>

<!--
$ ruby mondai7.rb
"TochuKasou"
-->


<p>試しにnormal.exeの引数に、このコードを実行して得られたキーを与えて実行してみたところ、以下のようになりました。</p>

<p><img src="/blog/resources/images//TochuKasou.png" alt="TochuKasou.png" /></p>

<p>この文字列を与えてmondai8.zipを解凍してmondai7は終了です。</p>

<pre><code class="sh">&gt; 7z.exe x mondai8.zip

7-Zip [64] 9.35 beta  Copyright (c) 1999-2014 Igor Pavlov  2014-12-07

Processing archive: mondai8.zip

Extracting  mondai8.tc
Enter password (will not be echoed):

Extracting  mondai8.txt
Extracting  mondai9.zip

Everything is Ok

Files: 3
Size:       70339136
Compressed: 70339594

Kernel  Time =     0.015 =    0%
User    Time =     1.170 =   21%
Process Time =     1.185 =   22%    Virtual  Memory =      2 MB
Global  Time =     5.379 =  100%    Physical Memory =      4 MB
</code></pre>

<!--
$ wine 7z x mondai8.zip -pTochuKasou

7-Zip [64] 9.20  Copyright (c) 1999-2010 Igor Pavlov  2010-11-18
p7zip Version 9.20 (locale=utf8,Utf16=on,HugeFiles=on,4 CPUs)

Processing archive: mondai8.zip

Extracting  mondai8.tc
Extracting  mondai8.txt
Extracting  mondai9.zip

Everything is Ok

Files: 3
Size:       70339136
Compressed: 70339594
-->


<h1>mondai8</h1>

<p>なにやら怪しげなファイルmondai8.tcと問題文mondai8.txtがあります。mondai8.txtには以下のような記述がありました。
<code>
TrueCrypt pass:mondai8
漢字８文字
</code></p>

<p>mondai8.tcはTrueCryptファイルで、開くためのパスワードはmondai8であるとのことです。そしてこのmondai8の答えは漢字8文字ということでしょう。
TrueCryptでmondai8.tcをマウントして中を見てみました。</p>

<p><img src="/blog/resources/images//mondai8-files.png" alt="mondai8-files.png" /></p>

<p>こういったCTF系の問題でイメージファイルが配布されるときは、フォレンジック問題であると相場が決まっているので、TrueCryptでマウントしたらAutopsyで調査します。</p>

<p><img src="/blog/resources/images//autopsy.png" alt="autopsy.png" /></p>

<p>マウントした際に表示されていたファイルになかった「今日の本.xlsx」という削除されたファイルが見つかりました。怪しいですね。
復元してファイルを開いてみます。</p>

<p><img src="/blog/resources/images//todaysbook1.png" alt="todaysbook1.png" />
<img src="/blog/resources/images//todaysbook2.png" alt="todaysbook2.png" />
<img src="/blog/resources/images//todaysbook3.png" alt="todaysbook3.png" /></p>

<p>シート1にはアルファベットと2つの数字が書かれた行があり、シート2には、<a href="http://www.aozora.gr.jp/cards/001670/card56113.html">青空文庫の奇談クラブ</a>からコピーされたであろう本の内容が書かれていました。</p>

<p>シート3には、key:passwordに対応するanswerを入力するような空欄がありました。
このpasswordという文字列はきっとシート1のアルファベットと2つの数字に対応していて、1つ目の数字は行番号、2つ目の数字はその行の文字の位置を指しているだろうと思いました。
Excel Onlineの印刷機能でシート2をHTML形式にし、保存したのちテキストに変換して<a href="/blog/resources/data/2015/04/15/kidanclub.txt">kidanclub.txt</a>を作成し、
シート1を基に、アルファベット<strong>&#8220;password&#8221;</strong>に対応する行から文字を抽出するコードを書きました。</p>

<p><img src="/blog/resources/images//print-book.png" alt="print-book.png" /></p>

<pre><code class="ruby">#!/usr/bin/env ruby
password = [
    [119,161], # p
    [ 62, 11], # a
    [276, 40], # s
    [276, 40], # s
    [ 18, 58], # w
    [239, 44], # o
    [236,  7], # r
    [185,  7]  # d
]

book = File.open(ARGV[0], "r").readlines
key = ""
for i in password do
    # One-based numbering
    key += book[i[0] - 1][i[1] - 1]
end

p key
</code></pre>

<p>引数に先ほど作成した<a href="/blog/resources/data/2015/04/15/kidanclub.txt">kidanclub.txt</a>を与えて実行してみると、漢字8文字のパスワードを得ることができました。</p>

<!--
$ ruby mondai8.rb kidanclub.txt
"意気揚揚明鏡止水"
-->


<p>mondai5同様、非ASCII文字のパスワードなので、<code>7z.exe</code>を利用してmondai9.zipを解凍しておしまいです。</p>

<pre><code class="sh">&gt; 7z.exe x mondai9.zip

7-Zip [64] 9.35 beta  Copyright (c) 1999-2014 Igor Pavlov  2014-12-07

Processing archive: mondai9.zip

Extracting  mondai10.tc
Enter password (will not be echoed):

Extracting  mondai9.pkt

Everything is Ok

Files: 2
Size:       68517107
Compressed: 68241943

Kernel  Time =     0.046 =    1%
User    Time =     0.733 =   16%
Process Time =     0.780 =   17%    Virtual  Memory =      2 MB
Global  Time =     4.536 =  100%    Physical Memory =      4 MB
</code></pre>

<!--
$ wine 7z.exe x mondai9.zip -p意気揚揚明鏡止水

7-Zip [64] 9.35 beta  Copyright (c) 1999-2014 Igor Pavlov  2014-12-07

Processing archive: mondai9.zip

Extracting  mondai10.tc
Extracting  mondai9.pkt

Everything is Ok

Files: 2
Size:       68517107
Compressed: 68241943

Kernel  Time =     0.046 =    5%
User    Time =     0.733 =   87%
Process Time =     0.780 =   93%    Virtual  Memory =      2 MB
Global  Time =     0.836 =  100%    Physical Memory =      4 MB
-->


<h1>mondai9</h1>

<p>mondai9.pktは<code>file</code>コマンドによると、little-endianなpcapファイルのようです。</p>

<pre><code>$ file mondai9.pkt
mondai9.pkt: tcpdump capture file (little-endian) - version 2.4 (Ethernet, capture length 65535)
</code></pre>

<p>また、拡張子pktはWindowsの関連付けでは、Wiresharkで開けるファイルとなっています。
早速Wiresharkで見てみます。</p>

<p><img src="/blog/resources/images//mondai9-wireshark1.png" alt="mondai9-wireshark1.png" /></p>

<p>ざっと目を通した感じ、<code>tcpdump -f 'tcp port 80'</code>によって、fast-uploader.comにアクセスしている様子をキャプチャしたもののようです。</p>

<p><img src="/blog/resources/images//mondai9-wireshark2.png" alt="mondai9-wireshark2.png" /></p>

<p>httpリクエストで絞り込むと、POSTメソッドによってファイルを幾つかアップロードしているようです。</p>

<p><img src="/blog/resources/images//mondai9-wireshark3.png" alt="mondai9-wireshark3.png" /></p>

<p>アップロードしたファイルを抽出しようとメニューのHTTP objectから抽出を試みたのですが、Wiresharkでは<em>multipart/form-data</em>としてPOSTされたデータ中のファイルはうまく取り出せないようなので、NetworkMinerを使います。</p>

<p><img src="/blog/resources/images//mondai9-networkminer.png" alt="mondai9-networkminer.png" /></p>

<p>NetworkMinerで4つのアップロードされたファイルを抽出したところ、文字化けした2つのExcelファイルと1つのWordファイル、パスワードのかかったzipファイルがありました。
パスワードをクラックするとWordファイルが出てきたので、4つのOfficeファイルを開いてみました。</p>

<p><img src="/blog/resources/images//office-files.png" alt="office-files.png" /></p>

<p>どのOfficeファイルにも文字の記入はなく、答えらしきものがみつかりません。
ファイル名で検索してみたりいろいろしたあと、ファイルのメタ情報を詮索してみることにしたところ、文字化けしたWordファイルにそれらしきものがあることに気づきました。</p>

<p><img src="/blog/resources/images//word-property.png" alt="word-property.png" /></p>

<p>これパスワードとしてmondai10.tcをTrueCryptでマウントしてみたところ、開くことができました。</p>

<p>明日は最終問題、mondai10のWrite-upを公開します。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ネットエージェント最終面接問題 Write-up その2]]></title>
    <link href="http://mzyy94.com/blog/2015/04/14/netagent-mondai5-6/"/>
    <updated>2015-04-14T00:05:14+09:00</updated>
    <id>http://mzyy94.com/blog/2015/04/14/netagent-mondai5-6</id>
    <content type="html"><![CDATA[<p>ネットニュースサイトにも取り上げられ、盛り上がりを見せていたネットエージェントのいきなり最終面接mondaiのWrite-upその2です。</p>

<ul>
<li><a href="http://nlab.itmedia.co.jp/nl/articles/1503/30/news143.html">「解けたらいきなり最終面接」 ネットエージェント、今年も新卒向けに“難問”出題 - ねとらぼ</a></li>
</ul>


<p>某所ではこれらのmondaiを10分で解けたとの声が上がっているようで、世の中にはこの記事とは比べ物にならないくらい効率のよい解き方をしている方がいるようです。それらの解法と比べると、この記事の解法は全部解くのに数日かかっているので、内容が無いも同然という位置付けとなります。
もし10分で解いた猛者たちの解法が公開されていたら、この記事ではなくそちらをご覧になることをお勧めします。</p>

<p>昨日の<a href="/blog/2015/04/13/netagent-mondai1-4/">mondai1からmondai4までのWrite-upの記事</a>に続き、今日はmondai5とmondai6のWrite-upを公開します。</p>

<!-- more -->


<h1>mondai5</h1>

<p>mondai4.zipを解凍した際に出てきたファイル、mondai5は何だろうかと<code>file</code>コマンドを用いて調べると、ASCII textであるらしいことがわかります。テキストエディタで開いてみると、各行76文字で折り返されている、長いBASE64エンコードされた文字列が記載されていました。
そのまま<code>base64</code>に食べさせてデコードします。
<code>sh
$ base64 -D mondai5 -o mondai5-1
</code></p>

<p>デコードしてできたmondai5-1を<code>file</code>コマンドで調べてみるとまたもASCII textで、内容も先ほどと同じように、各行76文字で折り返されたBASE64エンコード文字列が書かれています。
同じように<code>base64</code>でデコードしてmondai5-2を作成します。</p>

<p>作成したmondai5-2を調べると、なんとmondai5、mondai5-1と同じ形で、またもBASE64エンコード文字列が書かれてるASCII textでした。
これもまた<code>base64</code>でデコードしてmondai5-3を作成します。
できあがった<strong>mondai5-3も同じ形式</strong>なので、同様の手順でmondai5-4を作成します。</p>

<p>mondai5-4は<code>file</code>コマンドで調べると、以下のように返してきます。
<code>sh
$ file mondai5-4
mondai5-4: uuencoded or xxencoded text
</code></p>

<p>uuencodeされた文字列が格納されているようです。
<code>uudecode</code>コマンドでmondai5-5を作成します。</p>

<pre><code class="sh">$ uudecode -o mondai5-5 mondai5-4
</code></pre>

<p>mondai5-5を調べてみるとgzip圧縮ファイルだということがわかります。
<code>sh
$ file mondai5-5
mondai5-5: gzip compressed data, from Unix, last modified: Thu Mar 19 17:31:56 2015
</code></p>

<p><code>gunzip</code>で解凍してmondai5-6を作成します。</p>

<pre><code class="sh">$ gunzip -d mondai5-5 -c &gt; mondai5-6
</code></pre>

<p>mondai5-6を調査してみましょう。<code>file</code>コマンドによるとzip圧縮ファイルとのことなので、中身を調べてみます。
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>file mondai5-6
</span><span class='line'>mondai5-6: Zip archive data, at least v1.0 to extract
</span><span class='line'><span class="nv">$ </span>7z l mondai5-6
</span><span class='line'>7-Zip <span class="o">[</span>64<span class="o">]</span> 9.20  Copyright <span class="o">(</span>c<span class="o">)</span> 1999-2010 Igor Pavlov  2010-11-18
</span><span class='line'>p7zip Version 9.20 <span class="o">(</span><span class="nv">locale</span><span class="o">=</span>utf8,Utf16<span class="o">=</span>on,HugeFiles<span class="o">=</span>on,4 CPUs<span class="o">)</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Listing archive: mondai5-6&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;--
</span><span class='line'><span class="nv">Path</span> <span class="o">=</span> mondai5-6
</span><span class='line'><span class="nv">Type</span> <span class="o">=</span> zip
</span><span class='line'>Physical <span class="nv">Size</span> <span class="o">=</span> 1472&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;   Date      Time    Attr         Size   Compressed  Name&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;2015-03-18 18:50:16 ....A         <span class="m">1332</span>         <span class="m">1332</span>  nek&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;hr /&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;                              <span class="m">1332</span>         <span class="m">1332</span>  <span class="m">1</span> files, <span class="m">0</span> folders
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;
</span><span class='line'>nekというファイルが格納されているようです。<span class="sb">`</span>7z<span class="sb">`</span>コマンドで解凍してnekを取り出します。
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;<span class="nv">$ </span>7z x mondai5-6&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;7-Zip <span class="o">[</span>64<span class="o">]</span> 9.20  Copyright <span class="o">(</span>c<span class="o">)</span> 1999-2010 Igor Pavlov  2010-11-18
</span><span class='line'>p7zip Version 9.20 <span class="o">(</span><span class="nv">locale</span><span class="o">=</span>utf8,Utf16<span class="o">=</span>on,HugeFiles<span class="o">=</span>on,4 CPUs<span class="o">)</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Processing archive: mondai5-6&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Extracting  nek&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Everything is Ok&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Size:       1332
</span><span class='line'>Compressed: 1472
</span></code></pre></td></tr></table></div></figure></p>

<p>nekを調べると、bzip圧縮ファイルとのことなので、<code>bzip2</code>コマンドで解凍します。</p>

<pre><code class="sh">$ file nek
nek: bzip2 compressed data, block size = 900k
$ bzip2 -d nek -c &gt; mondai5-8
</code></pre>

<p>mondai5-8は7z圧縮ファイルとのことなので、<code>7z</code>コマンドで解凍します。
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>file mondai5-8
</span><span class='line'>mondai5-8: 7-zip archive data, version 0.3
</span><span class='line'><span class="nv">$ </span>7z x mondai5-8&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;7-Zip <span class="o">[</span>64<span class="o">]</span> 9.20  Copyright <span class="o">(</span>c<span class="o">)</span> 1999-2010 Igor Pavlov  2010-11-18
</span><span class='line'>p7zip Version 9.20 <span class="o">(</span><span class="nv">locale</span><span class="o">=</span>utf8,Utf16<span class="o">=</span>on,HugeFiles<span class="o">=</span>on,4 CPUs<span class="o">)</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Processing archive: mondai5-8&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Extracting  n&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Everything is Ok&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;Size:       974
</span><span class='line'>Compressed: 1082
</span></code></pre></td></tr></table></div></figure></p>

<p>これによって、nというファイルが展開されます。このファイルはrar圧縮ファイルとのことなので<code>unrar</code>で解凍します。</p>

<pre><code class="sh">$ file n
n: RAR archive data, v1d, os: Win32
$ unrar x n

UNRAR 5.20 beta 1 freeware      Copyright (c) 1993-2014 Alexander Roshal


Extracting from n

Extracting  ne                                                        OK
All OK
</code></pre>

<p>neというファイルが出てきましたね。neはlha圧縮されたファイルとのことなので、<code>lha</code>コマンドで解凍します。</p>

<pre><code class="sh">$ file ne
ne: LHarc 1.x/ARX archive data [lh0]
$ lha x ne
nex     - Melted   :  o
</code></pre>

<p>nexファイルが出来上がりました。はい。調べるとxz圧縮なので<code>xz</code>で解凍します。</p>

<pre><code class="sh">$ file nex
nex: xz compressed data
$ xz -d nex -c &gt; mondai5-12
</code></pre>

<p>ちょっと疲れたのでコーヒーを飲みます。</p>

<p>mondai5-12を<code>file</code>コマンドで調べると、なんと、判定してくれません！（貧弱なfileめ）</p>

<pre><code class="sh">$ file mondai5-12
mondai5-12: data
</code></pre>

<p>マジックナンバーを見てみると、MSWIMとなってることが確認出ました。</p>

<pre><code class="sh">$ xxd mondai5-12 | head -2
0000000: 4d53 5749 4d00 0000 d000 0000 000d 0100  MSWIM...........
0000010: 8000 0000 0000 0000 4ef7 dcb4 6e01 bfe4  ........N...n...
</code></pre>

<p>Googleで「&#8221;MSWIM&#8221; magic number」として調べると、1番目に次のページがヒットします。</p>

<p><a href="http://en.wikipedia.org/wiki/Windows_Imaging_Format">Windows Imaging Format - Wikipedia, the free encyclopedia</a></p>

<p>このWikipediaの記事の最後に、<em>LZX圧縮だし7zとかで開けるよ（意訳）</em>と書いてあるので、<code>7z</code>で展開を試みてみます。</p>

<pre><code class="sh">$ 7z x mondai5-12

7-Zip [64] 9.20  Copyright (c) 1999-2010 Igor Pavlov  2010-11-18
p7zip Version 9.20 (locale=utf8,Utf16=on,HugeFiles=on,4 CPUs)

Processing archive: mondai5-12

Extracting  QRcode

Everything is Ok

Size:       16052
Compressed: 17310
</code></pre>

<p>あっさりと展開でき、QRcodeという名のファイルが出てきました。
このファイルの形式はSun raster image dataとのことです。</p>

<pre><code class="sh">$ file QRcode
QRcode: Sun raster image data, 123 x 123, 8-bit, RGB colormap
</code></pre>

<p>画像データらしいですが、開けるアプリケーションを持ち合わせていないので、ImageMagickに投げ込んでみます。</p>

<pre><code class="sh">$ convert QRcode qrcode.png
$ file qrcode.png
qrcode.png: PNG image data, 123 x 123, 4-bit grayscale, non-interlaced
</code></pre>

<p>さすがImageMagick難なく変換できたすごい！
簡単に開ける形式の画像ファイルができたので開いてみます。</p>

<p><img src="/blog/resources/images//qrcode.png" alt="qrcode.png" /></p>

<p><a href="/blog/2014/12/07/seccon2014-online/">半分食べられてしまったパンケーキ</a>ではなく、普通のQRコードでした。</p>

<p>適当なQRコードリーダーで読み込むと、以下のような文字列が得られます。
<code>
+BCcENQQxBEMEQAQwBEgEOgQw-
</code>
+で始まり-で終わる文字列、そう、UTF-7エンコード文字列です。
+と-の間はUTF-16のBASE64エンコード文字列（ただしパッディングの=が省略されている）なので、<code>nkf</code>で変換してみます。
<code>sh
$ echo BCcENQQxBEMEQAQwBEgEOgQw | nkf -mB -W16B
</code></p>

<!--
Чебурашка
-->


<p>何やらロシア語らしきものが出てきます。意味を調べると、ロシアの絵本のキャラクターとのことです。</p>

<p><img src="/blog/resources/images//Cheburashka.jpg" alt="Cheburashka.jpg" /></p>

<p>これ以上解くものがなくなったので、これがmondai5の答えのようです。しかし<code>7z</code>コマンドで解凍を試みても、パスワードが違うと言われる始末です。</p>

<p>p7zipの<code>7z</code>コマンドによる非ASCII文字パスワード付き7zipの解凍・圧縮は、環境によって正しく処理されないということを、以前日本語パスワードをセットしたときに経験したのを思い出し、本家7zipの<code>7z.exe</code>を使って解凍をしてみます。</p>

<pre><code class="sh">$ wine 7z.exe x mondai6.zip

7-Zip [64] 9.35 beta  Copyright (c) 1999-2014 Igor Pavlov  2014-12-07

Processing archive: mondai6.zip

Extracting  hint6.txt
Enter password (will not be echoed):

Extracting  mondai6.txt
Extracting  mondai7.zip

Everything is Ok

Files: 3
Size:       70362410
Compressed: 70373511

Kernel  Time =     0.046 =    1%
User    Time =     0.780 =   17%
Process Time =     0.826 =   18%    Virtual  Memory =      2 MB
Global  Time =     4.394 =  100%    Physical Memory =      4 MB
</code></pre>

<!--
$ wine 7z.exe x mondai6.zip -pЧебурашка

7-Zip [64] 9.35 beta  Copyright (c) 1999-2014 Igor Pavlov  2014-12-07

Processing archive: mondai6.zip

Extracting  hint6.txt
Extracting  mondai6.txt
Extracting  mondai7.zip

Everything is Ok

Files: 3
Size:       70362410
Compressed: 70373511

Kernel  Time =     0.046 =    5%
User    Time =     0.811 =   89%
Process Time =     0.858 =   94%    Virtual  Memory =      2 MB
Global  Time =     0.909 =  100%    Physical Memory =      4 MB
-->


<p>解凍できました！（やっと終わった。。）</p>

<h1>mondai6</h1>

<p>mondai6.txtには以下のように記載がありました。
<code>
http://49.212.84.208/cgi-bin/hode7hb376dgeas6df783gr4/mondai6.cgi
</code>
実際にこのURLにアクセスしに行くと、次のようなレスポンスを得られました。</p>

<pre><code class="sh">$ curl -v http://49.212.84.208/cgi-bin/hode7hb376dgeas6df783gr4/mondai6.cgi
* Hostname was NOT found in DNS cache
*   Trying 49.212.84.208...
* Connected to 49.212.84.208 (49.212.84.208) port 80 (#0)
&gt; GET /cgi-bin/hode7hb376dgeas6df783gr4/mondai6.cgi HTTP/1.1
&gt; User-Agent: curl/7.37.1
&gt; Host: 49.212.84.208
&gt; Accept: */*
&gt; 
&lt; HTTP/1.1 200 OK
&lt; Date: Tue, 07 Apr 2015 08:20:21 GMT
* Server Apache/2.2.3 (CentOS) is not blacklisted
&lt; Server: Apache/2.2.3 (CentOS)
&lt; Connection: close
&lt; Transfer-Encoding: chunked
&lt; Content-Type: text/html; charset=utf-8
&lt; 
{ [data not shown]

* Closing connection 0
&lt;HTML&gt;&lt;BODY&gt;use R4000
&lt;/BODY&gt;&lt;/HTML&gt;
</code></pre>

<p>なにやらR4000を使えとの文字だけが返ってきました。
R4000でGoogle検索すると、MIPSのプロセッサ情報がいくつか引っかかります。
MIPS R4000を搭載したデバイスでアクセスすればいいのかな？と思ったので、
Googleで「MIPS R4000 デバイス」で検索し、MIPS R4000搭載のデバイスを探してみました。</p>

<p><img src="/blog/resources/images//mips-r4000-search.png" alt="mips-r4000-search.png" /></p>

<p>検索結果1ページ目によると、PSPに搭載されているとの情報がいくつかヒットしていました。
早速PSPのブラウザからアクセスする際に送られるUser-Agentを調べてみます。</p>

<p><a href="http://www.openspc2.org/userAgent/">userAgent一覧/ユーザーエージェント一覧</a></p>

<p>このサイトによると、PSPのUAは、
<code>
Mozilla/4.0 (PSP PlayStation Portable); 2.00)
</code>
となっているようです。</p>

<p>早速このUAで先ほどのURLにアクセスしてみます。</p>

<pre><code class="sh">$ curl -v -A 'Mozilla/4.0 (PSP PlayStation Portable); 2.00)' http://49.212.84.208/cgi-bin/hode7hb376dgeas6df783gr4/mondai6.cgi
* Hostname was NOT found in DNS cache
*   Trying 49.212.84.208...
* Connected to 49.212.84.208 (49.212.84.208) port 80 (#0)
&gt; GET /cgi-bin/hode7hb376dgeas6df783gr4/mondai6.cgi HTTP/1.1
&gt; User-Agent: Mozilla/4.0 (PSP PlayStation Portable); 2.00)
&gt; Host: 49.212.84.208
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; Date: Tue, 07 Apr 2015 08:31:47 GMT
* Server Apache/2.2.3 (CentOS) is not blacklisted
&lt; Server: Apache/2.2.3 (CentOS)
&lt; Content-Length: 42
&lt; Connection: close
&lt; Content-Type: text/html; charset=utf-8
&lt;
* Closing connection 0
&lt;HTML&gt;&lt;BODY&gt;de la Bucure?ti
&lt;/BODY&gt;&lt;/HTML&gt;
</code></pre>

<p>レスポンスが変わりました。知らない国の言葉で書かれていたのでGoogle翻訳にタイプしてみると、ルーマニア語であるとの情報を得ました。</p>

<p>先ほどのレスポンスの一部文字が&#8221;?&#8221;となっているので、ルーマニア語を許容するヘッダーを付加すると表示が変わるかもしれないと思い、Accept-Languageにルーマニア語を指定してアクセスしてみました。</p>

<pre><code class="sh">$ curl -v -H 'Accept-Language: ro-RO' -A 'Mozilla/4.0 (PSP PlayStation Portable); 2.00)' http://49.212.84.208/cgi-bin/hode7hb376dgeas6df783gr4/mondai6.cgi
* Hostname was NOT found in DNS cache
*   Trying 49.212.84.208...
* Connected to 49.212.84.208 (49.212.84.208) port 80 (#0)
&gt; GET /cgi-bin/hode7hb376dgeas6df783gr4/mondai6.cgi HTTP/1.1
&gt; User-Agent: Mozilla/4.0 (PSP PlayStation Portable); 2.00)
&gt; Host: 49.212.84.208
&gt; Accept: */*
&gt; Accept-Language: ro-RO
&gt;
&lt; HTTP/1.1 200 OK
&lt; Date: Tue, 07 Apr 2015 08:35:33 GMT
* Server Apache/2.2.3 (CentOS) is not blacklisted
&lt; Server: Apache/2.2.3 (CentOS)
&lt; Connection: close
&lt; Transfer-Encoding: chunked
&lt; Content-Type: text/html; charset=utf-8
&lt;
* Closing connection 0
&lt;HTML&gt;&lt;BODY&gt;key: Minesweeper1990
&lt;/BODY&gt;&lt;/HTML&gt;
</code></pre>

<p>表示が変わり、mondai6の答えが出てきました。mondai7.zipのパスワードに指定して解凍してmondai6はおしまいです。</p>

<pre><code class="sh">$ 7z x mondai7.zip

7-Zip [64] 9.20  Copyright (c) 1999-2010 Igor Pavlov  2010-11-18
p7zip Version 9.20 (locale=utf8,Utf16=on,HugeFiles=on,4 CPUs)

Processing archive: mondai7.zip

Extracting  hint7.txt
Enter password (will not be echoed) :

Extracting  mondai8.zip
Extracting  normal.exe

Everything is Ok

Files: 3
Size:       70383731
Compressed: 70362268
</code></pre>

<!--
$ 7z x mondai7.zip -pMinesweeper1990

7-Zip [64] 9.20  Copyright (c) 1999-2010 Igor Pavlov  2010-11-18
p7zip Version 9.20 (locale=utf8,Utf16=on,HugeFiles=on,4 CPUs)

Processing archive: mondai7.zip

Extracting  hint7.txt
Extracting  mondai8.zip
Extracting  normal.exe

Everything is Ok

Files: 3
Size:       70383731
Compressed: 70362268
-->


<p>明日はmondai7からmondai9までのWrite-upを公開する予定です。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ネットエージェント最終面接問題 Write-up その1]]></title>
    <link href="http://mzyy94.com/blog/2015/04/13/netagent-mondai1-4/"/>
    <updated>2015-04-13T14:08:49+09:00</updated>
    <id>http://mzyy94.com/blog/2015/04/13/netagent-mondai1-4</id>
    <content type="html"><![CDATA[<p>恒例のネットエージェントのいきなり最終面接問題が3月末に公開されました。</p>

<ul>
<li><a href="http://www.netagent.co.jp/recruit/newgraduates_2016.html">2016年度 新卒採用｜ネットエージェント株式会社</a></li>
</ul>


<p>ネットニュースサイトにも取り上げられ（<a href="http://nlab.itmedia.co.jp/nl/articles/1503/30/news143.html">「解けたらいきなり最終面接」 ネットエージェント、今年も新卒向けに“難問”出題 - ねとらぼ</a>）、盛り上がりを見せていたあのmondaiです。
2016年新卒として、書類審査や2次選考を飛ばして最終面接を受けられるということなので本腰を入れて取り組んでみました。
このいきなり最終面接問題に関しては、全問正解しなければ回答の公開をしてはいけないとのことだったので察しがつくと思いますが、なんとかすべての問題をクリアできました。
これらmondaiを解いてきた過程をWrite-upとして残すことにしたので、興味がある方はご覧ください。</p>

<p>この記事ではmondai1からmondai4までの回答を掲載しています。</p>

<!-- more -->


<h1>mondai1</h1>

<pre><code>選考過程を縮めたい方に問題を用意いたしました。問題に答えると最終面接から始められます。 
※２０１６年３月卒業予定の方以外も挑戦していただけますが、採用対象とはなりません。
問題：LzYxMDIvcGouaGJwLy86cHR0aA==
</code></pre>

<p>BASE64でエンコードされた文字列を渡されるので、ちょちょっとコマンドを打つと逆さまになったURLがでてきます。</p>

<p>なので<code>rev</code>コマンドを噛ませて逆順にしてアクセス可能なURLが表示されたらmondai1はおしまいです。</p>

<pre><code class="sh">$ echo LzYxMDIvcGouaGJwLy86cHR0aA== | base64 -D | rev
</code></pre>

<!--
http://pbh.jp/2016/
-->


<h1>modai2</h1>

<p>mondai1の答えのURLにアクセスするとzip圧縮されたファイルを入手でき、そのファイルを展開するとmondai2.txtとzip形式の圧縮ファイルがあります。mondai2.txtの内容は以下の通りでした。</p>

<pre><code>2016の平方根の小数点以下2016桁目から20桁をパスワードにしました。
</code></pre>

<p>大きな有効数字の平方根を扱えるコマンドが*nix系システムには存在します。そう<code>bc</code>コマンドです。</p>

<p>この<code>bc</code>コマンドを用いて小数点以下2035桁(2015番目から20桁)の2016の平方根を計算させます。
<code>bc</code>コマンドによる出力は、適当な桁数で折り返しがあるので<code>perl</code>の正規表現を用いて削り、<code>tail</code>で終端から20バイトを取り出します。</p>

<pre><code class="sh">$ echo 'scale=2015+20;sqrt(2016)' | bc | perl -pe's/\\?\n//' | tail -c20
</code></pre>

<!--
74571026133060730881
-->


<p>これをパスワードとして入力すればmondai3.zipを解凍できます。</p>

<pre><code>$ 7z x mondai3.zip 

7-Zip [64] 9.20  Copyright (c) 1999-2010 Igor Pavlov  2010-11-18
p7zip Version 9.20 (locale=utf8,Utf16=on,HugeFiles=on,4 CPUs)

Processing archive: mondai3.zip

Extracting  hint3.txt
Enter password (will not be echoed) :

Extracting  mondai3.txt
Extracting  mondai4.zip

Everything is Ok

Files: 3
Size:       70392202
Compressed: 70392736
</code></pre>

<!--

$ 7za x mondai3.zip -p74571026133060730881

7-Zip (a) [64] 9.38 beta  Copyright (c) 1999-2014 Igor Pavlov  2015-01-03
p7zip Version 9.38.1 (locale=ja_JP.UTF-8,Utf16=on,HugeFiles=on,4 CPUs)

Processing archive: mondai3.zip

Extracting  hint3.txt
Extracting  mondai3.txt
Extracting  mondai4.zip

Everything is Ok

Files: 3
Size:       70392202
Compressed: 70392736

-->


<h1>mondai3</h1>

<p>mondai3.txtの中身は以下の通り。</p>

<pre><code>ハッシュパスワード問題
答え：３つの答えをつなげて

0f1aae8b8398c20f81e1c36e349a7880c9234c63
01821f5469967540a5a774197463e8c4d658f588
264f39cab871e4cfd65b3a002f7255888bb5ed97
</code></pre>

<p>パスワードを3つに分割してSHA1ハッシュを生成したものが記されており、それらの元の文字列を探し出せばいいというもの。広いWebの世界には単純な単語のハッシュ化前後のテーブルが存在し、手軽に利用できるものに
<a href="http://www.hashkiller.co.uk/sha1-decrypter.aspx">SHA1 Decrypter - SHA1 Decryption, Free SHA1 Decryptor, Online SHA1 Cracker, SHA1 Security</a>などがあります。このサイトに問題のハッシュ値をペーストして探索をかけると1秒足らずでハッシュ化前の数値を返してくれます。</p>

<p><img src="/blog/resources/images//hashkiller.png" alt="hashkiller.png" /></p>

<p>ここで得られた単語をそのままくっつけてパスワードに指定すると、mondai4.zipが解凍できます。</p>

<pre><code class="sh">$ 7z x mondai4.zip

7-Zip [64] 9.20  Copyright (c) 1999-2010 Igor Pavlov  2010-11-18
p7zip Version 9.20 (locale=utf8,Utf16=on,HugeFiles=on,4 CPUs)

Processing archive: mondai4.zip

Extracting  hint4.txt
Enter password (will not be echoed) :

Extracting  mondai4.png
Extracting  mondai5.zip

Everything is Ok

Files: 3
Size:       70391846
Compressed: 70391891
</code></pre>

<!--
$ 7za x mondai4.zip -ptokyouenoline

7-Zip (a) [64] 9.38 beta  Copyright (c) 1999-2014 Igor Pavlov  2015-01-03
p7zip Version 9.38.1 (locale=ja_JP.UTF-8,Utf16=on,HugeFiles=on,4 CPUs)

Processing archive: mondai4.zip

Extracting  hint4.txt
Extracting  mondai4.png
Extracting  mondai5.zip

Everything is Ok

Files: 3
Size:       70391846
Compressed: 70391891

-->


<h1>mondai4</h1>

<p><img src="/blog/resources/images//mondai4.png" alt="mondai4.png" />
mondai4.pngはヒエログリフが書かれた画像です。ヒエログリフを読解できなければ問題文すら読めない状況なので、ヒエログリフ学習サイトを探して学びます。以下のサイトを参考に3分ほどで学びました。</p>

<ul>
<li><a href="http://www004.upp.so-net.ne.jp/anubis/j50/jp50.html">日本語五十音をヒエログリフで表現</a></li>
</ul>


<p>ヒエログリフを学び終わると、すらすらと画像の文字が読めるようになるので、日本語に起こします。</p>

<pre><code>のらかちいくち　てちのちんちもちみら　もにみちもにみら　もにとちのにみちもちい　のらもらま
</code></pre>

<p>ぱっと見で平仮名で換字式暗号化された英文もしくはローマ字の文だと想像がつきます。ここで適当な文節として二言目の「てちのちんちもちみら」をGoogleで検索してみると、上位にヒットしたものにこの暗号の手がかりがでてきます。</p>

<p><img src="/blog/resources/images//techinochi-search.png" alt="techinochi-search.png" /></p>

<p>日本語キーボードのかな入力モードにしてローマ字の文を打った文は、母音に位置する「ら」や「ち」が多く登場することから、この暗号方式はカナ入力のままのローマ字打ちだと断定しました。
しかし英字キーボードユーザーなので、かなが印刷されたキーボードを持っていません。仕方なしにWikimediaでそれっぽい画像を拾ってきて、平仮名⇆アルファベット変換を行うと、上記の平仮名文字列は以下のように変換できます。</p>

<pre><code>kotaeha wakayamano minamino misakinamae komoji
</code></pre>

<p>「答えは和歌山の南の岬名前小文字」とのことです。早速Googleマップを開いて和歌山県の南にある岬を探します。</p>

<p><img src="/blog/resources/images//wakayama-map.png" alt="wakayama-map.png" /></p>

<p>探すと潮岬（読み：しおのみさき）が和歌山の南部にある岬なので、これをアルファベット小文字にしてパスワードにして回答終了…だとおもってました。
<strong>shionomisaki</strong>としてタイプしてもパスワードが間違っていると言われ、解凍できません。「もしや違う岬なのかな？」と思い、和歌山の岬をいろいろ調べて同じように入力しても開きません。もうだめ&#8230;と心折れそうになってしまったので、あとはBruteForceに任せようと、次のような適当なスクリプトを書いて放置しました。</p>

<pre><code class="ruby">#!/usr/bin/env ruby

# kana 50 components
vowel5 = ['a', 'i', 'u', 'e', 'o']
consonant5 = ['k', 's', 'sh', 't', 'ch', 'n', 'h', 'm', 'r', 'g', 'z', 'j', 'd', 'b', 'p']
vowel3 = ['a', 'u', 'o']
consonant3 = ['y', 'ky', 'sy', 'ts', 'ny', 'hy', 'by', 'gy', 'py', 'w']


# kana list
list = ['']

for v in vowel5 do
    list.push v
end

for c in consonant5 do
    for v in vowel5 do
        list.push c + v
        list.push c[0] + c + v
    end
end

for c in consonant3 do
    for v in vowel3 do
        list.push c + v
        list.push c[0] + c + v
    end
end

list.push 'nn'


locker = Mutex::new

# Wordlist generator
queue = []
Thread.start {
    q = ['','','','','','']
    for p0 in list do
        for p1 in list do
            for p2 in list do
                for p3 in list do
                    for p4 in list do
                        for p5 in list do
                            q[5] = p5
                            qq = q.join
                            unless qq =~ /^(.)\1/ then
                                locker.synchronize { queue.push qq }
                            end
                        end
                        q[4] = p4
                    end
                    q[3] = p3
                end
                q[2] = p2
            end
            q[1] = p1
        end
        q[0] = p0
    end
}



# Password cracker
puts 'Cracking...'
thread_count = 128
threads = []
found = false
thread_count.times do |i|
    threads &lt;&lt; Thread.start {
        loop do
            break if found
            break unless queue
            pass = locker.synchronize { queue.shift } + "misaki"
            t = system "7za x -p#{pass} -so mondai5.zip &gt; /dev/null 2&gt; /dev/null"
            if t then
                found = true
                puts '## PASS FOUND ##'
                open("pass.txt", "a") {|f| f.puts pass }
                puts 'pass saved.'
            end
        end
    }
end


threads.each { |th| th.join }
</code></pre>

<p>1時間ほどお風呂に入って放置していたら、答えが吐き出されていました。
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span><span class="nb">time</span> ./solver.rb
</span><span class='line'>Cracking...&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h2&gt;PASS FOUND&lt;/h2&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;pass saved.&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;real    16m44.573s
</span><span class='line'>user    30m36.171s
</span><span class='line'>sys     18m7.269s
</span></code></pre></td></tr></table></div></figure></p>

<p>潮岬（読み：しおのみさき）の「潮」の字を「うしお」と読み違えて（？）パスワードに設定していたようです。</p>

<p>このパスワードを入力することでmondai5.zipを展開することができました。</p>

<pre><code>$ 7z x mondai5.zip

7-Zip [64] 9.20  Copyright (c) 1999-2010 Igor Pavlov  2010-11-18
p7zip Version 9.20 (locale=utf8,Utf16=on,HugeFiles=on,4 CPUs)

Processing archive: mondai5.zip

Extracting  hint5.txt
Enter password (will not be echoed) :

Extracting  mondai5
Extracting  mondai6.zip

Everything is Ok

Files: 3
Size:       70380412
Compressed: 70378640
</code></pre>

<!--

$ 7za x mondai5.zip -pushiomisaki

7-Zip (a) [64] 9.38 beta  Copyright (c) 1999-2014 Igor Pavlov  2015-01-03
p7zip Version 9.38.1 (locale=ja_JP.UTF-8,Utf16=on,HugeFiles=on,4 CPUs)

Processing archive: mondai5.zip

Extracting  hint5.txt
Extracting  mondai5
Extracting  mondai6.zip

Everything is Ok

Files: 3
Size:       70380412
Compressed: 70378640

-->


<p>mondai5以降のWrite-upは明日公開します。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SECCON2014 Online英語版予選 Write-up]]></title>
    <link href="http://mzyy94.com/blog/2014/12/07/seccon2014-online/"/>
    <updated>2014-12-07T17:59:06+09:00</updated>
    <id>http://mzyy94.com/blog/2014/12/07/seccon2014-online</id>
    <content type="html"><![CDATA[<p>昨日12月6日午前9時（日本時間）から12月7日午後5時までの32時間耐久CTFが行われたので参加してみました。
あまり活躍できずでしたがチャレンジしたもののまとめを記します。</p>

<!-- more -->


<h1>Get the key (Network 100)</h1>

<p><img src="/blog/resources/images/2014/12/7/NW100-1.png" alt="Get the key pcap file opened" />
配布されたパケットからキーの手がかりを探すというもの。
これはNWの基本問題だったので解説することはほとんどないです。
Wiresharkで開いてWebサイトのログイン情報が出るのでそれでアクセスしておしまい。</p>

<p><img src="/blog/resources/images/2014/12/7/NW100-2.png" alt="Get the key WebSite login" />
<img src="/blog/resources/images/2014/12/7/NW100Flag.png" alt="NW100Flag" /></p>

<h1>Reverseit (Bin 100)</h1>

<p>なにやら配られたファイルを反転しろというもの。
バイト列反転、ビット反転いろいろな反転方法を試したところ、
4bitごとに反転してあげるとJPEG画像に早変わり。</p>

<p><img src="/blog/resources/images/2014/12/7/BIN100Flag.jpg" alt="BIN100Flag" /></p>

<p>画像中のFLAGも左右反転してるので眼で見て脳内反転しておしまい。</p>

<pre><code class="C">#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char const* argv[])
{
    int in, out;
    if ((in = open("Reverseit", O_RDONLY)) != -1) {
        struct stat st;
        int i;
        char buf[2];

        out = open("reversed", O_RDWR|O_CREAT, 0666);
        stat("Reverseit", &amp;st);
        for (i = st.st_size - 1; i &gt;= 0; --i) {
            lseek(in, i, SEEK_SET);
            read(in, buf, 1);
            buf[0] = (buf[0] &amp; 0x0f &lt;&lt; 4) | ((buf[0] &amp; 0xf0) &gt;&gt; 4);
            write(out, buf, 1);
        }
    }
    return 0;
}
</code></pre>

<h1>SECCON Wars: The Flag Awakens (QR 300)</h1>

<p><a href="http://youtu.be/1pC56S17-_A">http://youtu.be/1pC56S17-_A</a>&#8220;>http://youtu.be/1pC56S17-_A&#8221;>http://youtu.be/1pC56S17-_A</a></a>
新ジャンルQRからの出題。
<a href="http://youtu.be/1pC56S17-_A">YouTubeの動画</a>を見ろとの指令のみが与えられた問題。</p>

<p><img src="/blog/resources/images/2014/12/7/QR300-1.png" alt="SECCON Wars QR code movie" /></p>

<p>よーく見るとSECCONのバナーが出るときに動画の下の方にQRコードが流れているのでそれをスキャンすればよさそう。</p>

<p>手順としては動画をまずローカルに引っ張り出して、QRコードの出現する54秒の時点から7秒間を16fpsで連番画像として抜き出します。
ファイル情報を確認すると320x240ピクセルなので、目視で下部3ピクセルに表示されてると仮定して、320x3ピクセルの画像に切り出します。
あとはこれを連結してノイズを減らして色反転すると、</p>

<p><img src="/blog/resources/images/2014/12/7/QR300Flag.jpg" alt="QR300 Flag" /></p>

<p>このようなQRコードが得られ、スキャンしてFLAGをゲットできます。</p>

<pre><code>ffmpeg -i SECCON_WARS.mp4 -ss 54 -t 7 -r 16 -f image2 %04d.jpg
identify 0001.jpg
convert *.jpg -crop '320x3+0+237' qr_%04d.jpg
convert -append qr_*.jpg qr_appended.jpg
convert -median 3 -negate qr_appended.jpg qr.jpg
</code></pre>

<h1>The Golden Gate (Programming 400)</h1>

<p><img src="/blog/resources/images/2014/12/7/GoldenGate.jpg" alt="The Golden Gate" /></p>

<p>自作ハードウェアエンコーダーの写真があって、それによってエンコードされた文字<code>BQDykmgZ0I6SaQnq4o/iEONudetXdPJdpl1UVSlU69oZOtvqnHfinOpcEfIjXy9okkVpsuw2kpKS==</code>をデコードしてくれとのこと。
このハードウェアエンコーダーはユニーバーサル基板上に作られていて、絡み合うジャンパ線がどう繋がっているのかをしっかり把握できれば回路図を起こすのは以外と簡単。</p>

<p><img src="/blog/resources/images/2014/12/7/TGG-1.jpg" alt="Handwriting Circuit" /></p>

<p>7400のNANDゲートによって入力から出力までの間は、2入力NANDの結果をさらにその2入力でそれぞれNANDし、それらをNANDするという、何度もNANDする処理が入ってるだけでした。
要するにXORです。</p>

<p>よって、プログラムは簡潔にできあがり、難なくFLAGを手に入れることができると思いました。</p>

<p>&#8230;思いました。</p>

<p>残念ながら時間中にFLAGは得られませんでした。</p>

<p>一点、デコードすべき文がなんなのかがわからなかったことがあります。BASE64にしては文字数が合わないのです。
そして、どのタクトスイッチがどのbitをさしているのか、アノード・カソードどちらなのか写真からよくわからない、など、躓く点が多かったのです。</p>

<p>SECCONは終わってしまいましたが、ヒントが出され、入力と出力とが対応付けられるようになりました。
<a href="https://www.youtube.com/watch?v=kaDjypSndMk">https://www.youtube.com/watch?v=kaDjypSndMk</a>&#8220;>https://www.youtube.com/watch?v=kaDjypSndMk&#8221;>https://www.youtube.com/watch?v=kaDjypSndMk</a></a></p>

<p>タクトスイッチによる入力が一部反転できてなかったようです。</p>

<p>入力文を正規のBASE64にして実行してみると、しっかりとgzipのデータとなり、フラッグを得られました。
<code>
echo "BQDykmgZ0I6SaQnq4o/iEONudetXdPJdpl1UVSlU69oZOtvqnHfinOpcEfIjXy9okkVpsuw2kpKS" | openssl base64 -d &gt; input
gcc goldengate.c -o gg
./gg input
file out
gzip -S .gz -d -c out
</code></p>

<pre><code class="C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;


#define B(y) ((*buf &gt;&gt; (y)) &amp; 1)

unsigned char nand(unsigned char a, unsigned char b) {
    if (a == 1 &amp;&amp; b == 1) {
        return 0;
    }
    return 1;
}

unsigned char xor(unsigned char a, unsigned char b) {
    return nand(nand(nand(a, b), a), nand(b, nand(a, b)));
}

void encoder(unsigned char *buf) {
    unsigned char a4 = xor(B(1)^1, B(6)^1);
    unsigned char a6 = xor(B(3), B(1)^1);
    unsigned char a5 = xor(a6, B(5));
    unsigned char g1 = xor(B(5), B(7));
    unsigned char a0 = xor(g1, B(0)^1);
    unsigned char a2 = xor(B(2),1);
    unsigned char g2 = xor(B(2), B(1)^1);
    unsigned char a1 = xor(a2, g2);
    unsigned char a3 = xor(g1, g2);
    unsigned char a7 = xor(B(4)^1, g2);
    int t =
        ((a7 &lt;&lt; 7) &amp; 128) |
        ((a6 &lt;&lt; 6) &amp; 64) |
        ((a5 &lt;&lt; 5) &amp; 32) |
        ((a4 &lt;&lt; 4) &amp; 16) |
        ((a3 &lt;&lt; 3) &amp; 8) |
        ((a2 &lt;&lt; 2) &amp; 4) |
        ((a1 &lt;&lt; 1) &amp; 2) |
        ((a0 &lt;&lt; 0) &amp; 1);
    *buf = ((unsigned char)t ^ 0xff);
}


int main(int argc, char const* argv[])
{
    int in;
    int out;
    struct stat st;
    unsigned char buf[1 + 1];
    char name[8];
    int i, j;
    unsigned char table[256];
    unsigned char c;

    if (argc != 2) {
        return 1;
    }

    // create table
    for (i = c = 0; i &lt; 256; c = ++i) {
        encoder(&amp;c);
        table[(int)c] = ((unsigned char)i &amp; 0xff);
    }

    if ((in = open(argv[1], O_RDONLY)) != -1) {
        stat(argv[1], &amp;st);
        out = open("out", O_RDWR|O_CREAT, 0666);

        for (i = 0; i &lt; st.st_size; i++) {
            read(in, buf, 1);
            buf[0] = table[buf[0]];
            write(out, buf, 1);
        }

        close(out);
        close(in);
    }
    return 0;
}
</code></pre>

<h1>QR (Easy) (QR 100)</h1>

<p><img src="/blog/resources/images/2014/12/7/QRCake.jpg" alt="QR Cake" /></p>

<p>昨年のSECCON 2013オンライン予選でも出題された、データビットの部分だけ残ってるQRコードを解析するという問題。
今回はパンケーキに焼いて食べてしまったようです。</p>

<p>おなじみ<a href="http://en.wikipedia.org/wiki/QR_code">英語版WikipediaのQRコード解説ページ</a>のデータ配置図を元にデータビットを埋めていくだけです。
今回のフラッグの形式は<code>SECCON{XXXXXXX}</code>なので、最初の6文字が&#8221;SECCON&#8221;になるようなマスクを<a href="http://www.swetake.com/qrcode/qr5.html">QRコードの解説サイト</a>を見ながら特定すると、マスクパターンは001であることがわかります。</p>

<p><img src="/blog/resources/images/2014/12/7/QR100-1.png" alt="QR Cake" /></p>

<p>あとは淡々とビットを解析して行って得たFLAGは、</p>

<pre>
0010 : 英数モード
000000110 : 6文字
10011111010 : 'SE'
01000101000 : 'CC'
10001001111 : 'ON'
0100 : 8bitバイトモード
00010010 : 18文字
01111011 : '{'
01010000 : 'P'
01010011 : 'S'
01110111 : 'w'
01011101 : ']'
01010001 : 'Q'
00111001 : '9'
01100100 : 'd'
00111001 : '9'
01000111 : 'G'
01101010 : 'j'
01001011 : 'K'
01010100 : 'T'
01100100 : 'd'
01000100 : 'D'
00111000 : '8'
01001000 : 'H'
01111101 : '}'
0101
11
</pre>


<p><code>SECCON{PSw]Q9d9GjKTdD8H}</code>
しかし<strong>Incorrect.</strong></p>

<p>骨の折れる作業で再度トライする気にはならなかったのですが、
今になって見返してみると間違ってるビットを発見。
正解は<code>SECCON{PSwIQ9d9GjKTdD8H}</code>;</p>

<h2>おしまい</h2>

<p>チーム合計で2500点でした(´Д` )</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SECCON 2014 横浜大会NW予選 Write-up]]></title>
    <link href="http://mzyy94.com/blog/2014/09/03/seccon2014-yokohama-2nd-day/"/>
    <updated>2014-09-03T14:40:47+09:00</updated>
    <id>http://mzyy94.com/blog/2014/09/03/seccon2014-yokohama-2nd-day</id>
    <content type="html"><![CDATA[<p>SECCON 2014 横浜大会に参加してきました。
NW,BIN,WEBと３部門の予選がありましたが、ネットワーク大好き♡なのでNWにチャレンジしました。</p>

<p>ネットワーク部門は10問ある問題を解いて答えを紙に書いて提出して採点された点数によって順位付けされ、成績優秀者10人が予選突破という選抜形式で行われました。</p>

<p>CTFにおけるネットワーク問題は年々減少傾向にある上、難易度を上げることが難しいとのことなので、今回は少し特殊なファイル形式で出題されていました。
例えば以下が問題1の出題ファイルです。</p>

<pre><code>Find the Key!

0000  00 00 00 00 00 00 00 00  00 00 00 00 08 00 45 00   ........ ......E.
0010  00 34 f3 ed 00 00 40 01  88 d9 7f 00 00 01 7f 00   .4....@. ........
0020  00 01 08 00 bd c8 18 18  00 00 5a 6d 78 68 5a 33   ........ ..ZmxhZ3
0030  74 7a 5a 57 4e 6a 62 32  35 7a 5a 57 4e 6a 62 32   tzZWNjb2 5zZWNjb2
0040  35 39 
</code></pre>

<p>そう、いいままでのpcapファイルでの出題ではなくテキストファイルでの出題となっていたのです。</p>

<p>このままでは今まで愛用してきたWiresharkおよび、tsharkでの解析ができません。
バイナリエディタにコピペして目grepしてもいいですが、ここはpcapファイルに変換してしまいましょう。</p>

<p>世の中には便利なソフトウェアが沢山あります。こんなときにもOSSが活躍します。
テキストファイルをpcapファイルに変換するソフトウェア、その名も<code>text2pcap</code>です。
これ、Wiresharkに付属してるんです。</p>

<p>使い方は簡単、例えば問題1の出題ファイルでは、1行目の問題文を削除してHEX部分だけにしたファイル、question-01.txtを作成し、
<code>text2pcap question-01.txt q01.pcap</code>などとすれば、Wiresharkで解析できるpcapファイルが作成されます。</p>

<p>さて、このようにしてさくさくと解けるファイルが作成できればあとは画面を凝視するのみ、順々に解いていきます。</p>

<!-- more -->


<h1>問題1</h1>

<pre><code>Find the Key!

0000  00 00 00 00 00 00 00 00  00 00 00 00 08 00 45 00   ........ ......E.
0010  00 34 f3 ed 00 00 40 01  88 d9 7f 00 00 01 7f 00   .4....@. ........
0020  00 01 08 00 bd c8 18 18  00 00 5a 6d 78 68 5a 33   ........ ..ZmxhZ3
0030  74 7a 5a 57 4e 6a 62 32  35 7a 5a 57 4e 6a 62 32   tzZWNjb2 5zZWNjb2
0040  35 39 
</code></pre>

<p>簡単ですね。
tsharkでパケットをチェックしてみると、
      1   0.000000    127.0.0.1 -> 127.0.0.1    ICMP 66 Echo (ping) request  id=0x1818, seq=0/0, ttl=64
と出力されるので、ICMPメッセージにフラッグが隠されてるんだろうなーっと想像つきます。
上記のファイルを見ると、目nkfで簡単に答えが出てきます。
目nkf力が無い人は、<code>echo ZmxhZ3tzZWNjb25zZWNjb259|nkf -mB</code>とでもやるとよいでしょう。</p>

<p>ということでフラッグは<code>secconseccon</code>でした。</p>

<h1>問題2</h1>

<pre><code>開いてるTCPポートを列挙せよ
</code></pre>

<p><a href="/blog/resources/data/2014/9/3/nmaped.pcap">nmaped.pcap</a></p>

<p>これはpcapファイルが添付されていました。
nmapでポートスキャンをしたときのログが残っているようです。
ポートが空いているということは、TCP FlagのSYNとACKが帰ってくるはずなので、SYN/ACKを返しているポートを列挙する適当なスクリプトを書きました。
node.js + node_pcapです。
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='JavaScript'><span class='line'><span class="kd">var</span> <span class="nx">filter</span> <span class="o">=</span> <span class="s2">&quot;tcp&quot;</span><span class="p">;</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="kd">var</span> <span class="nx">pcap</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;pcap&#39;</span><span class="p">),</span>
</span><span class='line'>    <span class="nx">pcap_session</span> <span class="o">=</span> <span class="nx">pcap</span><span class="p">.</span><span class="nx">createOfflineSession</span><span class="p">(</span><span class="s2">&quot;./nmaped.pcap&quot;</span><span class="p">,</span> <span class="nx">filter</span><span class="p">);</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">pcap_session</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;packet&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">raw_packet</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">packet</span> <span class="o">=</span> <span class="nx">pcap</span><span class="p">.</span><span class="nx">decode</span><span class="p">.</span><span class="nx">packet</span><span class="p">(</span><span class="nx">raw_packet</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">packet</span><span class="p">.</span><span class="nx">link</span><span class="p">.</span><span class="nx">ip</span><span class="p">.</span><span class="nx">tcp</span><span class="p">.</span><span class="nx">flags</span><span class="p">.</span><span class="nx">syn</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;</span><span class="nx">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="nx">amp</span><span class="p">;</span>
</span><span class='line'>        <span class="nx">packet</span><span class="p">.</span><span class="nx">link</span><span class="p">.</span><span class="nx">ip</span><span class="p">.</span><span class="nx">tcp</span><span class="p">.</span><span class="nx">flags</span><span class="p">.</span><span class="nx">ack</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">packet</span><span class="p">.</span><span class="nx">link</span><span class="p">.</span><span class="nx">ip</span><span class="p">.</span><span class="nx">tcp</span><span class="p">.</span><span class="nx">sport</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>これを02-solver.jsとして保存し、<code>npm install pcap &amp;&amp; node 02-solver.js | sort -n | uniq</code>としてあげれば答えのポートが出てきます。</p>

<h1>問題3</h1>

<pre><code>このパケットデータのアプリケーションプロトコルは何でしょう？
英字でお答えください。

0000   00 1a a0 89 a3 7f 44 94 fc 7e 1a ba 08 00 45 00  ......D..~....E.
0010   00 4c 00 00 40 00 36 11 11 2c d2 ad a0 1b c0 a8  .L..@.6..,......
0020   00 04 00 7b 00 7b 00 38 6d 96 1c 02 11 e8 00 00  ...{.{.8m.......
0030   06 8b 00 00 02 9e ac 1d 02 32 d7 ad 09 99 d8 db  .........2......
0040   8b 49 d7 ad 0a 44 7a a8 0f 7e d7 ad 0a 46 42 28  .I...Dz..~...FB(
0050   23 a6 d7 ad 0a 46 42 2b 5a b3                    #....FB+Z.
</code></pre>

<p>目grepで答えはすぐにわかるんですが、確認のためにtext2pcapを用いてpcapファイルにしてtsharkに食わせてみると、以下のように出力されます。</p>

<pre><code>$ tshark -r q03.pcap
  1   0.000000 210.173.160.27 -&gt; 192.168.0.4  NTP 90 NTP Version 3, server
</code></pre>

<p>NTPですね。</p>

<h1>問題4</h1>

<pre><code>サーバの名前は何？
FQDNでお答えください。

0000   00 1a a0 89 a3 7f 44 94 fc 7e 1a ba 08 00 45 00  ......D..~....E.
0010   00 4c 00 00 40 00 36 11 11 2c d2 ad a0 1b c0 a8  .L..@.6..,......
0020   00 04 00 7b 00 7b 00 38 6d 96 1c 02 11 e8 00 00  ...{.{.8m.......
0030   06 8b 00 00 02 9e ac 1d 02 32 d7 ad 09 99 d8 db  .........2......
0040   8b 49 d7 ad 0a 44 7a a8 0f 7e d7 ad 0a 46 42 28  .I...Dz..~...FB(
0050   23 a6 d7 ad 0a 46 42 2b 5a b3                    #....FB+Z.
</code></pre>

<p>先ほどと同じパケットデータなので、全問でtsharkを動かしたときの出力にあるIPアドレスに向けてnslookupしてあげれば答えがでます。</p>

<pre><code>$ nslookup 210.173.160.27
Server:     192.168.128.1
Address:    192.168.128.1#53

Non-authoritative answer:
27.160.173.210.in-addr.arpa name = ntp1.jst.mfeed.ad.jp.

Authoritative answers can be found from:
</code></pre>

<p>答えは、ntp1.jst.mfeed.ad.jp.です。</p>

<h1>問題5</h1>

<pre><code>このパケットによると、日本時間で今何月何日何時何分何秒？

0000   00 1a a0 89 a3 7f 44 94 fc 7e 1a ba 08 00 45 00  ......D..~....E.
0010   00 4c 00 00 40 00 36 11 11 2c d2 ad a0 1b c0 a8  .L..@.6..,......
0020   00 04 00 7b 00 7b 00 38 6d 96 1c 02 11 e8 00 00  ...{.{.8m.......
0030   06 8b 00 00 02 9e ac 1d 02 32 d7 ad 09 99 d8 db  .........2......
0040   8b 49 d7 ad 0a 44 7a a8 0f 7e d7 ad 0a 46 42 28  .I...Dz..~...FB(
0050   23 a6 d7 ad 0a 46 42 2b 5a b3                    #....FB+Z.
</code></pre>

<p>これも先ほどと同じパケットです。<code>tshark -r 03.pcap -V</code>とすると、Timestampの情報が現れるので時差と到達遅延を計算してあげれば答えが出ます。</p>

<h1>問題6</h1>

<pre><code>空欄となっている箇所の２バイトの値は？

00 66 77 88  99 AA 00 11  22 33 44 55  08 00 45 00
00 54 03 76  00 00 40 01  F3 DF C0 A8  01 01 C0 A8
01 02 08 00  48 FD 3B 04  00 6F 54 01  8D C5 00 0C
A6 B9 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15
16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25
26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35
36 37

00 11 22 33  44 55 00 66  77 88 99 AA  08 00 45 00
00 54 1E 0A  00 00 40 01  D9 4B C0 A8  01 02 C0 A8
01 01 00 00  -- -- 3B 04  00 6F 54 01  8D C5 00 0C
A6 B9 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15
16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25
26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35
36 37
</code></pre>

<p>目wiresharkするとわかると思いますが、求めるフラッグはICMPのChecksumです。
計算してもいいのですが、wireshark/tsharkのチェック機能を使ってさっくりと解いてしまいます。
&#8211;の部分に00を埋めてわざと間違っているであるだろうChecksumを入力してpcapファイルを作成し、
tsharkで詳細情報を見ると、以下のように出力されます。</p>

<pre><code>$ tshark -r q06.pcap -V
Frame 1: 98 bytes on wire (784 bits), 98 bytes captured (784 bits)
    Encapsulation type: Ethernet (1)
    Arrival Time: Sep  3, 2014 12:48:01.000000000 JST
    [Time shift for this packet: 0.000000000 seconds]
    Epoch Time: 1409716081.000000000 seconds
    [Time delta from previous captured frame: 0.000000000 seconds]
    [Time delta from previous displayed frame: 0.000000000 seconds]
    [Time since reference or first frame: 0.000000000 seconds]
    Frame Number: 1
    Frame Length: 98 bytes (784 bits)
    Capture Length: 98 bytes (784 bits)
    [Frame is marked: False]
    [Frame is ignored: False]
    [Protocols in frame: eth:ethertype:ip:icmp:data]
Ethernet II, Src: 00:66:77:88:99:aa (00:66:77:88:99:aa), Dst: 00:11:22:33:44:55 (00:11:22:33:44:55)
    Destination: 00:11:22:33:44:55 (00:11:22:33:44:55)
        Address: 00:11:22:33:44:55 (00:11:22:33:44:55)
        .... ..0. .... .... .... .... = LG bit: Globally unique address (factory default)
        .... ...0 .... .... .... .... = IG bit: Individual address (unicast)
    Source: 00:66:77:88:99:aa (00:66:77:88:99:aa)
        Address: 00:66:77:88:99:aa (00:66:77:88:99:aa)
        .... ..0. .... .... .... .... = LG bit: Globally unique address (factory default)
        .... ...0 .... .... .... .... = IG bit: Individual address (unicast)
    Type: IP (0x0800)
Internet Protocol Version 4, Src: 192.168.1.2 (192.168.1.2), Dst: 192.168.1.1 (192.168.1.1)
    Version: 4
    Header Length: 20 bytes
    Differentiated Services Field: 0x00 (DSCP 0x00: Default; ECN: 0x00: Not-ECT (Not ECN-Capable Transport))
        0000 00.. = Differentiated Services Codepoint: Default (0x00)
        .... ..00 = Explicit Congestion Notification: Not-ECT (Not ECN-Capable Transport) (0x00)
    Total Length: 84
    Identification: 0x1e0a (7690)
    Flags: 0x00
        0... .... = Reserved bit: Not set
        .0.. .... = Don't fragment: Not set
        ..0. .... = More fragments: Not set
    Fragment offset: 0
    Time to live: 64
    Protocol: ICMP (1)
    Header checksum: 0xd94b [validation disabled]
        [Good: False]
        [Bad: False]
    Source: 192.168.1.2 (192.168.1.2)
    Destination: 192.168.1.1 (192.168.1.1)
    [Source GeoIP: Unknown]
    [Destination GeoIP: Unknown]
Internet Control Message Protocol
    Type: 0 (Echo (ping) reply)
    Code: 0
    Checksum: 0x0000 [incorrect, should be 0x50fd]
    Identifier (BE): 15108 (0x3b04)
    Identifier (LE): 1083 (0x043b)
    Sequence number (BE): 111 (0x006f)
    Sequence number (LE): 28416 (0x6f00)
    Data (56 bytes)

0000  54 01 8d c5 00 0c a6 b9 08 09 0a 0b 0c 0d 0e 0f   T...............
0010  10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f   ................
0020  20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f    !"#$%&amp;'()*+,-./
0030  30 31 32 33 34 35 36 37                           01234567
        Data: 54018dc5000ca6b908090a0b0c0d0e0f1011121314151617...
        [Length: 56]
</code></pre>

<p>ICMPの項目を見てみると、
<code>   Checksum: 0x0000 [incorrect, should be 0x50fd]</code>
とあるので、答えにコレを記入して乙です。</p>

<h1>問題7</h1>

<pre><code>通信相手のIPアドレスは？次の4つのパケットを見て答えよ。

-- 1 --
000000: FF FF FF FF  FF FF 00 66  77 88 99 AA  08 06 00 01 : .......f w.......
000010: 08 00 06 04  00 01 00 66  77 88 99 AA  C0 A8 01 02 : .......f w.......
000020: 00 00 00 00  00 00 C0 A8  01 01                    : ........ ..
==
-- 2 --
000000: 00 66 77 88  99 AA 00 11  22 33 44 55  08 06 00 01 : .fw..... "3DU....
000010: 08 00 06 04  00 02 00 11  22 33 44 55  C0 A8 01 01 : ........ "3DU....
000020: 00 66 77 88  99 AA C0 A8  01 02 00 00  00 00 00 00 : .fw..... ........
000030: 00 00 00 00  00 00 00 00  00 00 00 00              : ........ ....
==
-- 3 --
000000: 00 11 22 33  44 55 00 66  77 88 99 AA  08 00 45 00 : .."3DU.f w.....E.
000010: 00 54 00 00  40 00 40 01  50 C3 C0 A8  01 02 0A 14 : .T..@.@. P.......
000020: 1E 28 08 00  D0 C0 7A 07  00 01 EA 6C  02 54 C9 72 : .(....z. ...l.T.r
000030: 0C 00 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &amp;'()*+,- ./012345
000060: 36 37                                              : 67
==
-- 4 --
000000: 00 66 77 88  99 AA 00 11  22 33 44 55  08 00 45 00 : .fw..... "3DU..E.
000010: 00 54 02 95  40 00 40 01  4E 2E 0A 14  1E 28 C0 A8 : .T..@.@. N....(..
000020: 01 02 00 00  D8 C0 7A 07  00 01 EA 6C  02 54 C9 72 : ......z. ...l.T.r
000030: 0C 00 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &amp;'()*+,- ./012345
000060: 36 37                                              : 67
==
</code></pre>

<p>pcapファイルを作成して、<code>tshark -r q07.pcap</code>とするだけです。それだけです。やってみてください。</p>

<h1>問題8</h1>

<pre><code>間違っているのは何バイト目？次の二つのパケットを見て答えよ。

-- 1 --
000000: FF FF FF FF  FF FF 00 11  22 33 44 55  08 06 00 01 : ........ "3DU....
000010: 08 00 08 04  00 01 00 11  22 33 44 55  C0 A8 01 01 : ........ "3DU....
000020: 00 00 00 00  00 00 C0 A8  01 02                    : ........ ..      
==
-- 2 --
000000: 00 11 22 33  44 55 00 66  77 88 99 AA  08 06 00 01 : .."3DU.f w.......
000010: 08 00 08 04  00 02 00 66  77 88 99 AA  C0 A8 01 02 : .......f w.......
000020: 00 11 22 33  44 55 C0 A8  01 01 00 00  00 00 00 00 : .."3DU.. ........
000030: 00 00 00 00  00 00 00 00  00 00 00 00              : ........ ....    
==
</code></pre>

<p>ぱっと見で大体予想はつくのですが、今回もpcapファイルを作成して見てみます。
tsharkの出力は以下のようになりました。
    $ tshark -r q08.pcap
      1   0.000000              ->              Ethernet 2 [Malformed Packet]
      2   0.000001 00:66:77:88:99:aa -> 00:11:22:33:44:55 ARP 60 1.2.0.17 is at 0066778899aac0a8</p>

<p>1パケット目が壊れてるようです。
この通信はARPの問い合わせの様子を示しているようで、ARPの構造を知っていればすぐに解ける問題です。
ARPのPDUは以下のようになっています。</p>

<pre><code> 0                               1
 0 1 2 3 4 5 6 7 8 9 a b c d e f 0 1 2 3 4 5 6 7 8 9 a b c d e f 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Hardware type         |           Protocol type       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  HW addr len  | Proto addr len|              OP Code          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Sender Hardware Address                      |
+                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               |   Sender Protocol Address     
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   Sender Protocol Address      |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                      Target Hardware Address                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Target Protocol address                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>

<p>これに0x000eから始まるEtherペイロードを合わせてみて見ると、HW addr lenの部分、すなわちARPリクエストのハードウェアアドレス長指定が間違っているのです。
この問い合わせはProtocol typeの部分からIP問い合わせであることがわかり、IPアドレス問い合わせのためにはMACアドレスに対するARP要求が行われます。
MACアドレスが物理層となり、EthernetのMACアドレスは6バイトなので、HW addr lenの部分は08ではなく、06である必要があります。</p>

<p>0x0012番地目の部分が間違っているので、19バイト目が答えとなります。</p>

<h1>問題9</h1>

<p>なぜか問題8と同じ</p>

<h1>問題10</h1>

<pre><code>このパケットデータの??の部分に表示される文字列をお答えください。

0000  00 00 00 00 00 00 00 00  00 00 00 00 08 00 45 00   ........ ......E.
0010  00 54 00 00 40 00 40 01  3c a7 7f 00 00 01 7f 00   .T..@.@. &lt;.......
0020  00 01 08 00 ba 0c 02 18  00 01 d7 c2 05 54 00 00   ........ .....T..
0030  00 00 91 f0 0e 00 00 00  00 00 10 11 12 13 14 15   ........ ........
0040  16 17 18 19 1a 1b 1c 1d  1e 1f 20 21 22 23 24 25   ........ .. ?????
0050  26 27 28 29 2a 2b 2c 2d  2e 2f 30 31 32 33 34 35   ?????????????????
0060  36 37                                              ??
</code></pre>

<p>パケットの問題ではないね。
ASCIIコードテーブル片手に0x21から0x37までのASCII文字を記入しておしまい。</p>

<h3>感想</h3>

<p>CTF予選問題としては出題ファイル形式含めてもちょっと優しすぎるかなぁといった印象を持ちました。
さくさくと解けるものが多く、難しいものは無かったように感じます。
ただ、text2pcapの存在を知らない人に取っては結構な時間を取られてしまう骨の折れるような問題群だったと思います。</p>

<blockquote class="twitter-tweet" lang="ja"><p>わいわい <a href="http://t.co/YaEfzCCFq8">pic.twitter.com/YaEfzCCFq8</a></p>&mdash; 誕生日前日amzn.to/1vvKISb (@mzyy94) <a href="https://twitter.com/mzyy94/status/507067029547806720">2014, 9月 3</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

]]></content>
  </entry>
  
</feed>

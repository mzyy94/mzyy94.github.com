<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ctf | 犬アイコンのみっきー]]></title>
  <link href="http://mzyy94.com/blog/categories/ctf/atom.xml" rel="self"/>
  <link href="http://mzyy94.com/"/>
  <updated>2015-03-18T11:09:25+09:00</updated>
  <id>http://mzyy94.com/</id>
  <author>
    <name><![CDATA[mzyy94]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SECCON2014 Online英語版予選 Write-up]]></title>
    <link href="http://mzyy94.com/blog/2014/12/07/seccon2014-online/"/>
    <updated>2014-12-07T17:59:06+09:00</updated>
    <id>http://mzyy94.com/blog/2014/12/07/seccon2014-online</id>
    <content type="html"><![CDATA[<p>昨日12月6日午前9時（日本時間）から12月7日午後5時までの32時間耐久CTFが行われたので参加してみました。
あまり活躍できずでしたがチャレンジしたもののまとめを記します。</p>

<!-- more -->


<h1>Get the key (Network 100)</h1>

<p><img src="/blog/resources/images/2014/12/7/NW100-1.png" alt="Get the key pcap file opened" />
配布されたパケットからキーの手がかりを探すというもの。
これはNWの基本問題だったので解説することはほとんどないです。
Wiresharkで開いてWebサイトのログイン情報が出るのでそれでアクセスしておしまい。</p>

<p><img src="/blog/resources/images/2014/12/7/NW100-2.png" alt="Get the key WebSite login" />
<img src="/blog/resources/images/2014/12/7/NW100Flag.png" alt="NW100Flag" /></p>

<h1>Reverseit (Bin 100)</h1>

<p>なにやら配られたファイルを反転しろというもの。
バイト列反転、ビット反転いろいろな反転方法を試したところ、
4bitごとに反転してあげるとJPEG画像に早変わり。</p>

<p><img src="/blog/resources/images/2014/12/7/BIN100Flag.jpg" alt="BIN100Flag" /></p>

<p>画像中のFLAGも左右反転してるので眼で見て脳内反転しておしまい。</p>

<pre><code class="C">#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char const* argv[])
{
    int in, out;
    if ((in = open("Reverseit", O_RDONLY)) != -1) {
        struct stat st;
        int i;
        char buf[2];

        out = open("reversed", O_RDWR|O_CREAT, 0666);
        stat("Reverseit", &amp;st);
        for (i = st.st_size - 1; i &gt;= 0; --i) {
            lseek(in, i, SEEK_SET);
            read(in, buf, 1);
            buf[0] = (buf[0] &amp; 0x0f &lt;&lt; 4) | ((buf[0] &amp; 0xf0) &gt;&gt; 4);
            write(out, buf, 1);
        }
    }
    return 0;
}
</code></pre>

<h1>SECCON Wars: The Flag Awakens (QR 300)</h1>

<p><a href="http://youtu.be/1pC56S17-_A">http://youtu.be/1pC56S17-_A</a>&#8220;>http://youtu.be/1pC56S17-_A&#8221;>http://youtu.be/1pC56S17-_A</a></a>
新ジャンルQRからの出題。
<a href="http://youtu.be/1pC56S17-_A">YouTubeの動画</a>を見ろとの指令のみが与えられた問題。</p>

<p><img src="/blog/resources/images/2014/12/7/QR300-1.png" alt="SECCON Wars QR code movie" /></p>

<p>よーく見るとSECCONのバナーが出るときに動画の下の方にQRコードが流れているのでそれをスキャンすればよさそう。</p>

<p>手順としては動画をまずローカルに引っ張り出して、QRコードの出現する54秒の時点から7秒間を16fpsで連番画像として抜き出します。
ファイル情報を確認すると320x240ピクセルなので、目視で下部3ピクセルに表示されてると仮定して、320x3ピクセルの画像に切り出します。
あとはこれを連結してノイズを減らして色反転すると、</p>

<p><img src="/blog/resources/images/2014/12/7/QR300Flag.jpg" alt="QR300 Flag" /></p>

<p>このようなQRコードが得られ、スキャンしてFLAGをゲットできます。</p>

<pre><code>ffmpeg -i SECCON_WARS.mp4 -ss 54 -t 7 -r 16 -f image2 %04d.jpg
identify 0001.jpg
convert *.jpg -crop '320x3+0+237' qr_%04d.jpg
convert -append qr_*.jpg qr_appended.jpg
convert -median 3 -negate qr_appended.jpg qr.jpg
</code></pre>

<h1>The Golden Gate (Programming 400)</h1>

<p><img src="/blog/resources/images/2014/12/7/GoldenGate.jpg" alt="The Golden Gate" /></p>

<p>自作ハードウェアエンコーダーの写真があって、それによってエンコードされた文字<code>BQDykmgZ0I6SaQnq4o/iEONudetXdPJdpl1UVSlU69oZOtvqnHfinOpcEfIjXy9okkVpsuw2kpKS==</code>をデコードしてくれとのこと。
このハードウェアエンコーダーはユニーバーサル基板上に作られていて、絡み合うジャンパ線がどう繋がっているのかをしっかり把握できれば回路図を起こすのは以外と簡単。</p>

<p><img src="/blog/resources/images/2014/12/7/TGG-1.jpg" alt="Handwriting Circuit" /></p>

<p>7400のNANDゲートによって入力から出力までの間は、2入力NANDの結果をさらにその2入力でそれぞれNANDし、それらをNANDするという、何度もNANDする処理が入ってるだけでした。
要するにXORです。</p>

<p>よって、プログラムは簡潔にできあがり、難なくFLAGを手に入れることができると思いました。</p>

<p>&#8230;思いました。</p>

<p>残念ながら時間中にFLAGは得られませんでした。</p>

<p>一点、デコードすべき文がなんなのかがわからなかったことがあります。BASE64にしては文字数が合わないのです。
そして、どのタクトスイッチがどのbitをさしているのか、アノード・カソードどちらなのか写真からよくわからない、など、躓く点が多かったのです。</p>

<p>SECCONは終わってしまいましたが、ヒントが出され、入力と出力とが対応付けられるようになりました。
<a href="https://www.youtube.com/watch?v=kaDjypSndMk">https://www.youtube.com/watch?v=kaDjypSndMk</a>&#8220;>https://www.youtube.com/watch?v=kaDjypSndMk&#8221;>https://www.youtube.com/watch?v=kaDjypSndMk</a></a></p>

<p>タクトスイッチによる入力が一部反転できてなかったようです。</p>

<p>入力文を正規のBASE64にして実行してみると、しっかりとgzipのデータとなり、フラッグを得られました。
<code>
echo "BQDykmgZ0I6SaQnq4o/iEONudetXdPJdpl1UVSlU69oZOtvqnHfinOpcEfIjXy9okkVpsuw2kpKS" | openssl base64 -d &gt; input
gcc goldengate.c -o gg
./gg input
file out
gzip -S .gz -d -c out
</code></p>

<pre><code class="C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;


#define B(y) ((*buf &gt;&gt; (y)) &amp; 1)

unsigned char nand(unsigned char a, unsigned char b) {
    if (a == 1 &amp;&amp; b == 1) {
        return 0;
    }
    return 1;
}

unsigned char xor(unsigned char a, unsigned char b) {
    return nand(nand(nand(a, b), a), nand(b, nand(a, b)));
}

void encoder(unsigned char *buf) {
    unsigned char a4 = xor(B(1)^1, B(6)^1);
    unsigned char a6 = xor(B(3), B(1)^1);
    unsigned char a5 = xor(a6, B(5));
    unsigned char g1 = xor(B(5), B(7));
    unsigned char a0 = xor(g1, B(0)^1);
    unsigned char a2 = xor(B(2),1);
    unsigned char g2 = xor(B(2), B(1)^1);
    unsigned char a1 = xor(a2, g2);
    unsigned char a3 = xor(g1, g2);
    unsigned char a7 = xor(B(4)^1, g2);
    int t =
        ((a7 &lt;&lt; 7) &amp; 128) |
        ((a6 &lt;&lt; 6) &amp; 64) |
        ((a5 &lt;&lt; 5) &amp; 32) |
        ((a4 &lt;&lt; 4) &amp; 16) |
        ((a3 &lt;&lt; 3) &amp; 8) |
        ((a2 &lt;&lt; 2) &amp; 4) |
        ((a1 &lt;&lt; 1) &amp; 2) |
        ((a0 &lt;&lt; 0) &amp; 1);
    *buf = ((unsigned char)t ^ 0xff);
}


int main(int argc, char const* argv[])
{
    int in;
    int out;
    struct stat st;
    unsigned char buf[1 + 1];
    char name[8];
    int i, j;
    unsigned char table[256];
    unsigned char c;

    if (argc != 2) {
        return 1;
    }

    // create table
    for (i = c = 0; i &lt; 256; c = ++i) {
        encoder(&amp;c);
        table[(int)c] = ((unsigned char)i &amp; 0xff);
    }

    if ((in = open(argv[1], O_RDONLY)) != -1) {
        stat(argv[1], &amp;st);
        out = open("out", O_RDWR|O_CREAT, 0666);

        for (i = 0; i &lt; st.st_size; i++) {
            read(in, buf, 1);
            buf[0] = table[buf[0]];
            write(out, buf, 1);
        }

        close(out);
        close(in);
    }
    return 0;
}
</code></pre>

<h1>QR (Easy) (QR 100)</h1>

<p><img src="/blog/resources/images/2014/12/7/QRCake.jpg" alt="QR Cake" /></p>

<p>昨年のSECCON 2013オンライン予選でも出題された、データビットの部分だけ残ってるQRコードを解析するという問題。
今回はパンケーキに焼いて食べてしまったようです。</p>

<p>おなじみ<a href="http://en.wikipedia.org/wiki/QR_code">英語版WikipediaのQRコード解説ページ</a>のデータ配置図を元にデータビットを埋めていくだけです。
今回のフラッグの形式は<code>SECCON{XXXXXXX}</code>なので、最初の6文字が&#8221;SECCON&#8221;になるようなマスクを<a href="http://www.swetake.com/qrcode/qr5.html">QRコードの解説サイト</a>を見ながら特定すると、マスクパターンは001であることがわかります。</p>

<p><img src="/blog/resources/images/2014/12/7/QR100-1.png" alt="QR Cake" /></p>

<p>あとは淡々とビットを解析して行って得たFLAGは、</p>

<pre>
0010 : 英数モード
000000110 : 6文字
10011111010 : 'SE'
01000101000 : 'CC'
10001001111 : 'ON'
0100 : 8bitバイトモード
00010010 : 18文字
01111011 : '{'
01010000 : 'P'
01010011 : 'S'
01110111 : 'w'
01011101 : ']'
01010001 : 'Q'
00111001 : '9'
01100100 : 'd'
00111001 : '9'
01000111 : 'G'
01101010 : 'j'
01001011 : 'K'
01010100 : 'T'
01100100 : 'd'
01000100 : 'D'
00111000 : '8'
01001000 : 'H'
01111101 : '}'
0101
11
</pre>


<p><code>SECCON{PSw]Q9d9GjKTdD8H}</code>
しかし<strong>Incorrect.</strong></p>

<p>骨の折れる作業で再度トライする気にはならなかったのですが、
今になって見返してみると間違ってるビットを発見。
正解は<code>SECCON{PSwIQ9d9GjKTdD8H}</code>;</p>

<h2>おしまい</h2>

<p>チーム合計で2500点でした(´Д` )</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SECCON 2014 横浜大会NW予選 Write-up]]></title>
    <link href="http://mzyy94.com/blog/2014/09/03/seccon2014-yokohama-2nd-day/"/>
    <updated>2014-09-03T14:40:47+09:00</updated>
    <id>http://mzyy94.com/blog/2014/09/03/seccon2014-yokohama-2nd-day</id>
    <content type="html"><![CDATA[<p>SECCON 2014 横浜大会に参加してきました。
NW,BIN,WEBと３部門の予選がありましたが、ネットワーク大好き♡なのでNWにチャレンジしました。</p>

<p>ネットワーク部門は10問ある問題を解いて答えを紙に書いて提出して採点された点数によって順位付けされ、成績優秀者10人が予選突破という選抜形式で行われました。</p>

<p>CTFにおけるネットワーク問題は年々減少傾向にある上、難易度を上げることが難しいとのことなので、今回は少し特殊なファイル形式で出題されていました。
例えば以下が問題1の出題ファイルです。</p>

<pre><code>Find the Key!

0000  00 00 00 00 00 00 00 00  00 00 00 00 08 00 45 00   ........ ......E.
0010  00 34 f3 ed 00 00 40 01  88 d9 7f 00 00 01 7f 00   .4....@. ........
0020  00 01 08 00 bd c8 18 18  00 00 5a 6d 78 68 5a 33   ........ ..ZmxhZ3
0030  74 7a 5a 57 4e 6a 62 32  35 7a 5a 57 4e 6a 62 32   tzZWNjb2 5zZWNjb2
0040  35 39 
</code></pre>

<p>そう、いいままでのpcapファイルでの出題ではなくテキストファイルでの出題となっていたのです。</p>

<p>このままでは今まで愛用してきたWiresharkおよび、tsharkでの解析ができません。
バイナリエディタにコピペして目grepしてもいいですが、ここはpcapファイルに変換してしまいましょう。</p>

<p>世の中には便利なソフトウェアが沢山あります。こんなときにもOSSが活躍します。
テキストファイルをpcapファイルに変換するソフトウェア、その名も<code>text2pcap</code>です。
これ、Wiresharkに付属してるんです。</p>

<p>使い方は簡単、例えば問題1の出題ファイルでは、1行目の問題文を削除してHEX部分だけにしたファイル、question-01.txtを作成し、
<code>text2pcap question-01.txt q01.pcap</code>などとすれば、Wiresharkで解析できるpcapファイルが作成されます。</p>

<p>さて、このようにしてさくさくと解けるファイルが作成できればあとは画面を凝視するのみ、順々に解いていきます。</p>

<!-- more -->


<h1>問題1</h1>

<pre><code>Find the Key!

0000  00 00 00 00 00 00 00 00  00 00 00 00 08 00 45 00   ........ ......E.
0010  00 34 f3 ed 00 00 40 01  88 d9 7f 00 00 01 7f 00   .4....@. ........
0020  00 01 08 00 bd c8 18 18  00 00 5a 6d 78 68 5a 33   ........ ..ZmxhZ3
0030  74 7a 5a 57 4e 6a 62 32  35 7a 5a 57 4e 6a 62 32   tzZWNjb2 5zZWNjb2
0040  35 39 
</code></pre>

<p>簡単ですね。
tsharkでパケットをチェックしてみると、
      1   0.000000    127.0.0.1 -> 127.0.0.1    ICMP 66 Echo (ping) request  id=0x1818, seq=0/0, ttl=64
と出力されるので、ICMPメッセージにフラッグが隠されてるんだろうなーっと想像つきます。
上記のファイルを見ると、目nkfで簡単に答えが出てきます。
目nkf力が無い人は、<code>echo ZmxhZ3tzZWNjb25zZWNjb259|nkf -mB</code>とでもやるとよいでしょう。</p>

<p>ということでフラッグは<code>secconseccon</code>でした。</p>

<h1>問題2</h1>

<pre><code>開いてるTCPポートを列挙せよ
</code></pre>

<p><a href="/blog/resources/data/2014/9/3/nmaped.pcap">nmaped.pcap</a></p>

<p>これはpcapファイルが添付されていました。
nmapでポートスキャンをしたときのログが残っているようです。
ポートが空いているということは、TCP FlagのSYNとACKが帰ってくるはずなので、SYN/ACKを返しているポートを列挙する適当なスクリプトを書きました。
node.js + node_pcapです。
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='JavaScript'><span class='line'><span class="kd">var</span> <span class="nx">filter</span> <span class="o">=</span> <span class="s2">&quot;tcp&quot;</span><span class="p">;</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="kd">var</span> <span class="nx">pcap</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;pcap&#39;</span><span class="p">),</span>
</span><span class='line'>    <span class="nx">pcap_session</span> <span class="o">=</span> <span class="nx">pcap</span><span class="p">.</span><span class="nx">createOfflineSession</span><span class="p">(</span><span class="s2">&quot;./nmaped.pcap&quot;</span><span class="p">,</span> <span class="nx">filter</span><span class="p">);</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">pcap_session</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;packet&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">raw_packet</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">packet</span> <span class="o">=</span> <span class="nx">pcap</span><span class="p">.</span><span class="nx">decode</span><span class="p">.</span><span class="nx">packet</span><span class="p">(</span><span class="nx">raw_packet</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">packet</span><span class="p">.</span><span class="nx">link</span><span class="p">.</span><span class="nx">ip</span><span class="p">.</span><span class="nx">tcp</span><span class="p">.</span><span class="nx">flags</span><span class="p">.</span><span class="nx">syn</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;</span><span class="nx">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="nx">amp</span><span class="p">;</span>
</span><span class='line'>        <span class="nx">packet</span><span class="p">.</span><span class="nx">link</span><span class="p">.</span><span class="nx">ip</span><span class="p">.</span><span class="nx">tcp</span><span class="p">.</span><span class="nx">flags</span><span class="p">.</span><span class="nx">ack</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">packet</span><span class="p">.</span><span class="nx">link</span><span class="p">.</span><span class="nx">ip</span><span class="p">.</span><span class="nx">tcp</span><span class="p">.</span><span class="nx">sport</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>これを02-solver.jsとして保存し、<code>npm install pcap &amp;&amp; node 02-solver.js | sort -n | uniq</code>としてあげれば答えのポートが出てきます。</p>

<h1>問題3</h1>

<pre><code>このパケットデータのアプリケーションプロトコルは何でしょう？
英字でお答えください。

0000   00 1a a0 89 a3 7f 44 94 fc 7e 1a ba 08 00 45 00  ......D..~....E.
0010   00 4c 00 00 40 00 36 11 11 2c d2 ad a0 1b c0 a8  .L..@.6..,......
0020   00 04 00 7b 00 7b 00 38 6d 96 1c 02 11 e8 00 00  ...{.{.8m.......
0030   06 8b 00 00 02 9e ac 1d 02 32 d7 ad 09 99 d8 db  .........2......
0040   8b 49 d7 ad 0a 44 7a a8 0f 7e d7 ad 0a 46 42 28  .I...Dz..~...FB(
0050   23 a6 d7 ad 0a 46 42 2b 5a b3                    #....FB+Z.
</code></pre>

<p>目grepで答えはすぐにわかるんですが、確認のためにtext2pcapを用いてpcapファイルにしてtsharkに食わせてみると、以下のように出力されます。</p>

<pre><code>$ tshark -r q03.pcap
  1   0.000000 210.173.160.27 -&gt; 192.168.0.4  NTP 90 NTP Version 3, server
</code></pre>

<p>NTPですね。</p>

<h1>問題4</h1>

<pre><code>サーバの名前は何？
FQDNでお答えください。

0000   00 1a a0 89 a3 7f 44 94 fc 7e 1a ba 08 00 45 00  ......D..~....E.
0010   00 4c 00 00 40 00 36 11 11 2c d2 ad a0 1b c0 a8  .L..@.6..,......
0020   00 04 00 7b 00 7b 00 38 6d 96 1c 02 11 e8 00 00  ...{.{.8m.......
0030   06 8b 00 00 02 9e ac 1d 02 32 d7 ad 09 99 d8 db  .........2......
0040   8b 49 d7 ad 0a 44 7a a8 0f 7e d7 ad 0a 46 42 28  .I...Dz..~...FB(
0050   23 a6 d7 ad 0a 46 42 2b 5a b3                    #....FB+Z.
</code></pre>

<p>先ほどと同じパケットデータなので、全問でtsharkを動かしたときの出力にあるIPアドレスに向けてnslookupしてあげれば答えがでます。</p>

<pre><code>$ nslookup 210.173.160.27
Server:     192.168.128.1
Address:    192.168.128.1#53

Non-authoritative answer:
27.160.173.210.in-addr.arpa name = ntp1.jst.mfeed.ad.jp.

Authoritative answers can be found from:
</code></pre>

<p>答えは、ntp1.jst.mfeed.ad.jp.です。</p>

<h1>問題5</h1>

<pre><code>このパケットによると、日本時間で今何月何日何時何分何秒？

0000   00 1a a0 89 a3 7f 44 94 fc 7e 1a ba 08 00 45 00  ......D..~....E.
0010   00 4c 00 00 40 00 36 11 11 2c d2 ad a0 1b c0 a8  .L..@.6..,......
0020   00 04 00 7b 00 7b 00 38 6d 96 1c 02 11 e8 00 00  ...{.{.8m.......
0030   06 8b 00 00 02 9e ac 1d 02 32 d7 ad 09 99 d8 db  .........2......
0040   8b 49 d7 ad 0a 44 7a a8 0f 7e d7 ad 0a 46 42 28  .I...Dz..~...FB(
0050   23 a6 d7 ad 0a 46 42 2b 5a b3                    #....FB+Z.
</code></pre>

<p>これも先ほどと同じパケットです。<code>tshark -r 03.pcap -V</code>とすると、Timestampの情報が現れるので時差と到達遅延を計算してあげれば答えが出ます。</p>

<h1>問題6</h1>

<pre><code>空欄となっている箇所の２バイトの値は？

00 66 77 88  99 AA 00 11  22 33 44 55  08 00 45 00
00 54 03 76  00 00 40 01  F3 DF C0 A8  01 01 C0 A8
01 02 08 00  48 FD 3B 04  00 6F 54 01  8D C5 00 0C
A6 B9 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15
16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25
26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35
36 37

00 11 22 33  44 55 00 66  77 88 99 AA  08 00 45 00
00 54 1E 0A  00 00 40 01  D9 4B C0 A8  01 02 C0 A8
01 01 00 00  -- -- 3B 04  00 6F 54 01  8D C5 00 0C
A6 B9 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15
16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25
26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35
36 37
</code></pre>

<p>目wiresharkするとわかると思いますが、求めるフラッグはICMPのChecksumです。
計算してもいいのですが、wireshark/tsharkのチェック機能を使ってさっくりと解いてしまいます。
&#8211;の部分に00を埋めてわざと間違っているであるだろうChecksumを入力してpcapファイルを作成し、
tsharkで詳細情報を見ると、以下のように出力されます。</p>

<pre><code>$ tshark -r q06.pcap -V
Frame 1: 98 bytes on wire (784 bits), 98 bytes captured (784 bits)
    Encapsulation type: Ethernet (1)
    Arrival Time: Sep  3, 2014 12:48:01.000000000 JST
    [Time shift for this packet: 0.000000000 seconds]
    Epoch Time: 1409716081.000000000 seconds
    [Time delta from previous captured frame: 0.000000000 seconds]
    [Time delta from previous displayed frame: 0.000000000 seconds]
    [Time since reference or first frame: 0.000000000 seconds]
    Frame Number: 1
    Frame Length: 98 bytes (784 bits)
    Capture Length: 98 bytes (784 bits)
    [Frame is marked: False]
    [Frame is ignored: False]
    [Protocols in frame: eth:ethertype:ip:icmp:data]
Ethernet II, Src: 00:66:77:88:99:aa (00:66:77:88:99:aa), Dst: 00:11:22:33:44:55 (00:11:22:33:44:55)
    Destination: 00:11:22:33:44:55 (00:11:22:33:44:55)
        Address: 00:11:22:33:44:55 (00:11:22:33:44:55)
        .... ..0. .... .... .... .... = LG bit: Globally unique address (factory default)
        .... ...0 .... .... .... .... = IG bit: Individual address (unicast)
    Source: 00:66:77:88:99:aa (00:66:77:88:99:aa)
        Address: 00:66:77:88:99:aa (00:66:77:88:99:aa)
        .... ..0. .... .... .... .... = LG bit: Globally unique address (factory default)
        .... ...0 .... .... .... .... = IG bit: Individual address (unicast)
    Type: IP (0x0800)
Internet Protocol Version 4, Src: 192.168.1.2 (192.168.1.2), Dst: 192.168.1.1 (192.168.1.1)
    Version: 4
    Header Length: 20 bytes
    Differentiated Services Field: 0x00 (DSCP 0x00: Default; ECN: 0x00: Not-ECT (Not ECN-Capable Transport))
        0000 00.. = Differentiated Services Codepoint: Default (0x00)
        .... ..00 = Explicit Congestion Notification: Not-ECT (Not ECN-Capable Transport) (0x00)
    Total Length: 84
    Identification: 0x1e0a (7690)
    Flags: 0x00
        0... .... = Reserved bit: Not set
        .0.. .... = Don't fragment: Not set
        ..0. .... = More fragments: Not set
    Fragment offset: 0
    Time to live: 64
    Protocol: ICMP (1)
    Header checksum: 0xd94b [validation disabled]
        [Good: False]
        [Bad: False]
    Source: 192.168.1.2 (192.168.1.2)
    Destination: 192.168.1.1 (192.168.1.1)
    [Source GeoIP: Unknown]
    [Destination GeoIP: Unknown]
Internet Control Message Protocol
    Type: 0 (Echo (ping) reply)
    Code: 0
    Checksum: 0x0000 [incorrect, should be 0x50fd]
    Identifier (BE): 15108 (0x3b04)
    Identifier (LE): 1083 (0x043b)
    Sequence number (BE): 111 (0x006f)
    Sequence number (LE): 28416 (0x6f00)
    Data (56 bytes)

0000  54 01 8d c5 00 0c a6 b9 08 09 0a 0b 0c 0d 0e 0f   T...............
0010  10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f   ................
0020  20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f    !"#$%&amp;'()*+,-./
0030  30 31 32 33 34 35 36 37                           01234567
        Data: 54018dc5000ca6b908090a0b0c0d0e0f1011121314151617...
        [Length: 56]
</code></pre>

<p>ICMPの項目を見てみると、
<code>   Checksum: 0x0000 [incorrect, should be 0x50fd]</code>
とあるので、答えにコレを記入して乙です。</p>

<h1>問題7</h1>

<pre><code>通信相手のIPアドレスは？次の4つのパケットを見て答えよ。

-- 1 --
000000: FF FF FF FF  FF FF 00 66  77 88 99 AA  08 06 00 01 : .......f w.......
000010: 08 00 06 04  00 01 00 66  77 88 99 AA  C0 A8 01 02 : .......f w.......
000020: 00 00 00 00  00 00 C0 A8  01 01                    : ........ ..
==
-- 2 --
000000: 00 66 77 88  99 AA 00 11  22 33 44 55  08 06 00 01 : .fw..... "3DU....
000010: 08 00 06 04  00 02 00 11  22 33 44 55  C0 A8 01 01 : ........ "3DU....
000020: 00 66 77 88  99 AA C0 A8  01 02 00 00  00 00 00 00 : .fw..... ........
000030: 00 00 00 00  00 00 00 00  00 00 00 00              : ........ ....
==
-- 3 --
000000: 00 11 22 33  44 55 00 66  77 88 99 AA  08 00 45 00 : .."3DU.f w.....E.
000010: 00 54 00 00  40 00 40 01  50 C3 C0 A8  01 02 0A 14 : .T..@.@. P.......
000020: 1E 28 08 00  D0 C0 7A 07  00 01 EA 6C  02 54 C9 72 : .(....z. ...l.T.r
000030: 0C 00 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &amp;'()*+,- ./012345
000060: 36 37                                              : 67
==
-- 4 --
000000: 00 66 77 88  99 AA 00 11  22 33 44 55  08 00 45 00 : .fw..... "3DU..E.
000010: 00 54 02 95  40 00 40 01  4E 2E 0A 14  1E 28 C0 A8 : .T..@.@. N....(..
000020: 01 02 00 00  D8 C0 7A 07  00 01 EA 6C  02 54 C9 72 : ......z. ...l.T.r
000030: 0C 00 08 09  0A 0B 0C 0D  0E 0F 10 11  12 13 14 15 : ........ ........
000040: 16 17 18 19  1A 1B 1C 1D  1E 1F 20 21  22 23 24 25 : ........ .. !"#$%
000050: 26 27 28 29  2A 2B 2C 2D  2E 2F 30 31  32 33 34 35 : &amp;'()*+,- ./012345
000060: 36 37                                              : 67
==
</code></pre>

<p>pcapファイルを作成して、<code>tshark -r q07.pcap</code>とするだけです。それだけです。やってみてください。</p>

<h1>問題8</h1>

<pre><code>間違っているのは何バイト目？次の二つのパケットを見て答えよ。

-- 1 --
000000: FF FF FF FF  FF FF 00 11  22 33 44 55  08 06 00 01 : ........ "3DU....
000010: 08 00 08 04  00 01 00 11  22 33 44 55  C0 A8 01 01 : ........ "3DU....
000020: 00 00 00 00  00 00 C0 A8  01 02                    : ........ ..      
==
-- 2 --
000000: 00 11 22 33  44 55 00 66  77 88 99 AA  08 06 00 01 : .."3DU.f w.......
000010: 08 00 08 04  00 02 00 66  77 88 99 AA  C0 A8 01 02 : .......f w.......
000020: 00 11 22 33  44 55 C0 A8  01 01 00 00  00 00 00 00 : .."3DU.. ........
000030: 00 00 00 00  00 00 00 00  00 00 00 00              : ........ ....    
==
</code></pre>

<p>ぱっと見で大体予想はつくのですが、今回もpcapファイルを作成して見てみます。
tsharkの出力は以下のようになりました。
    $ tshark -r q08.pcap
      1   0.000000              ->              Ethernet 2 [Malformed Packet]
      2   0.000001 00:66:77:88:99:aa -> 00:11:22:33:44:55 ARP 60 1.2.0.17 is at 0066778899aac0a8</p>

<p>1パケット目が壊れてるようです。
この通信はARPの問い合わせの様子を示しているようで、ARPの構造を知っていればすぐに解ける問題です。
ARPのPDUは以下のようになっています。</p>

<pre><code> 0                               1
 0 1 2 3 4 5 6 7 8 9 a b c d e f 0 1 2 3 4 5 6 7 8 9 a b c d e f 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Hardware type         |           Protocol type       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  HW addr len  | Proto addr len|              OP Code          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Sender Hardware Address                      |
+                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                               |   Sender Protocol Address     
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   Sender Protocol Address      |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +
|                      Target Hardware Address                  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Target Protocol address                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>

<p>これに0x000eから始まるEtherペイロードを合わせてみて見ると、HW addr lenの部分、すなわちARPリクエストのハードウェアアドレス長指定が間違っているのです。
この問い合わせはProtocol typeの部分からIP問い合わせであることがわかり、IPアドレス問い合わせのためにはMACアドレスに対するARP要求が行われます。
MACアドレスが物理層となり、EthernetのMACアドレスは6バイトなので、HW addr lenの部分は08ではなく、06である必要があります。</p>

<p>0x0012番地目の部分が間違っているので、19バイト目が答えとなります。</p>

<h1>問題9</h1>

<p>なぜか問題8と同じ</p>

<h1>問題10</h1>

<pre><code>このパケットデータの??の部分に表示される文字列をお答えください。

0000  00 00 00 00 00 00 00 00  00 00 00 00 08 00 45 00   ........ ......E.
0010  00 54 00 00 40 00 40 01  3c a7 7f 00 00 01 7f 00   .T..@.@. &lt;.......
0020  00 01 08 00 ba 0c 02 18  00 01 d7 c2 05 54 00 00   ........ .....T..
0030  00 00 91 f0 0e 00 00 00  00 00 10 11 12 13 14 15   ........ ........
0040  16 17 18 19 1a 1b 1c 1d  1e 1f 20 21 22 23 24 25   ........ .. ?????
0050  26 27 28 29 2a 2b 2c 2d  2e 2f 30 31 32 33 34 35   ?????????????????
0060  36 37                                              ??
</code></pre>

<p>パケットの問題ではないね。
ASCIIコードテーブル片手に0x21から0x37までのASCII文字を記入しておしまい。</p>

<h3>感想</h3>

<p>CTF予選問題としては出題ファイル形式含めてもちょっと優しすぎるかなぁといった印象を持ちました。
さくさくと解けるものが多く、難しいものは無かったように感じます。
ただ、text2pcapの存在を知らない人に取っては結構な時間を取られてしまう骨の折れるような問題群だったと思います。</p>

<blockquote class="twitter-tweet" lang="ja"><p>わいわい <a href="http://t.co/YaEfzCCFq8">pic.twitter.com/YaEfzCCFq8</a></p>&mdash; 誕生日前日amzn.to/1vvKISb (@mzyy94) <a href="https://twitter.com/mzyy94/status/507067029547806720">2014, 9月 3</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

]]></content>
  </entry>
  
</feed>

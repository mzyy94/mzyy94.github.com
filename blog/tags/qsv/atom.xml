<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: qsv | 犬アイコンのみっきー]]></title>
  <link href="http://mzyy94.com/blog/tags/qsv/atom.xml" rel="self"/>
  <link href="http://mzyy94.com/"/>
  <updated>2015-08-08T21:17:29+09:00</updated>
  <id>http://mzyy94.com/</id>
  <author>
    <name><![CDATA[mzyy94]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[LinuxでQSVとH.264のエンコード対決]]></title>
    <link href="http://mzyy94.com/blog/2015/01/31/qsv-x264-linux-battle/"/>
    <updated>2015-01-31T19:23:04+09:00</updated>
    <id>http://mzyy94.com/blog/2015/01/31/qsv-x264-linux-battle</id>
    <content type="html"><![CDATA[<p>先日の記事、でLinuxでH.264の動画をエンコードできることを紹介しました。
そのベンチマークをとってみました。QSVでのエンコードとlibx264を用いたエンコードの比較となります。</p>

<p>今回エンコード時間の比較に用いた動画は以下のものを利用しました。</p>

<p><em><a href="http://www.bigbuckbunny.org">Big Buck Bunny</a></em></p>

<p><img src="/blog/resources/images/2015/01/31/big-buck-bunny.png" alt="Big Buck Bunny" /></p>

<p>ここの、<code>big_buck_bunny_1080p_surround.avi</code>を以下の表のオプションでLibx264とQSVでのエンコードで変換し、比較をしてみました。</p>

<table>
<thead>
<tr>
<th style="text-align:center;">項目 </th>
<th style="text-align:center;"> 値</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">音声コーデック</td>
<td style="text-align:center;"> コピー</td>
</tr>
<tr>
<td style="text-align:center;">ビットレート</td>
<td style="text-align:center;">2000kbps</td>
</tr>
<tr>
<td style="text-align:center;">サイズ</td>
<td style="text-align:center;"> 1280x720</td>
</tr>
<tr>
<td style="text-align:center;">フレームレート</td>
<td style="text-align:center;"> 29.97</td>
</tr>
</tbody>
</table>


<p>このオプションで起動すると、<strong>ffmpeg -i big_buck_bunny_1080p_surround.avi -acodec copy -vcodec コーデック -b:v 2000k -s 1280x720 -r 30000/1001 -y 出力ファイル</strong>という起動オプションになります。</p>

<!-- more -->


<h1>仮想8コアでx264エンコード</h1>

<p>Xeon搭載マシンで動かしているKVMに仮想8コアを割り当てた環境でエンコードしてみました。
FFmpegの粋な計らいによって、エンコード中は以下のようにたくさんのスレッドが立ちがあり、マシンはエンコードに専念していました。</p>

<p><img src="/blog/resources/images/2015/01/31/x264-8core-encode.png" alt="x264 8core encode" /></p>

<p>CPUはエンコード中、全コア90%前後の使用率を維持していました。そんなエンコードにかかった時間は以下の通りでした。</p>

<pre><code>real    2m50.118s
user    20m15.617s
sys     0m7.375s
</code></pre>

<p>10分の動画を3分足らずでエンコードしてしまいました。恐るべきコア数の暴力。</p>

<h1>仮想8コアでQSVエンコード</h1>

<p>先ほどと同じ環境でQSVを用いたエンコードをしてみました。
こちらもFFmpegによって複数のスレッドによる処理がされるのですが、CPUの負荷は多くて各コア10%程度となる非常に省エネなエンコードとなっていました。</p>

<p><img src="/blog/resources/images/2015/01/31/qsv-8core-encode.png" alt="QSV 8core encode" /></p>

<p>こんな省エネでもエンコードに要する時間はそれほどかかりませんでした。</p>

<pre><code>real    3m6.697s
user    2m56.301s
sys     0m4.871s
</code></pre>

<p>3分とちょっとでエンコードが完了しています。さすがにXeon 8コアにはかなわないようです。</p>

<h1>仮想1コアでx264エンコード</h1>

<p>KVMで割り当てコア数を1コアに設定し、x264を用いたエンコードをしてみました。
負荷はほぼ100%、まれに90%前後になる程度でした。</p>

<p><img src="/blog/resources/images/2015/01/31/x264-1core-encode.png" alt="x264 1core encode" /></p>

<p>じっくりエンコードしてかかった時間は以下のとおりです。</p>

<pre><code>real    10m56.739s
user    10m54.374s
sys     0m1.070s
</code></pre>

<p>動画再生時間+10%程度の時間がかかっていました。</p>

<h1>仮想1コアでQSVエンコード</h1>

<p>QSVとコア数の関係性は不明ながら、比較のために同じ環境でQSVでもエンコードしてみました。
負荷はほとんどないかと思ってたのですが、エンコーダに渡す前処理などで少々CPUを使うようで、90%前後まで達したり0%付近をうろうろしたりと、不安定な負荷がかかっていました。また、なぜか2スレッドで処理していました。</p>

<p><img src="/blog/resources/images/2015/01/31/qsv-1core-encode.png" alt="qsv 1core encode" /></p>

<p>要した時間は以下のとおりです。</p>

<pre><code>real    3m0.692s
user    2m35.944s
sys     0m0.972s
</code></pre>

<p>予想はついていましたが、QSVでは8コアでも1コアでもほとんど時間は変わらないようです。</p>

<h1>仮想1コアで複数のQSVエンコード&#8230;?</h1>

<p>記事公開直後にこのような気になる意見をいただきました。</p>

<p><a href="https://twitter.com/polamjag/status/561469823561920513">https://twitter.com/polamjag/status/561469823561920513</a>&#8220;>https://twitter.com/polamjag/status/561469823561920513&#8221;>https://twitter.com/polamjag/status/561469823561920513</a></a></p>

<p>早速、QSVでの同時エンコードを試してみました。
tmuxで分割し、上下のコンソールで同時にエンコードを開始してみた結果が以下の画像のとおりになります。</p>

<p><img src="/blog/resources/images/2015/01/31/qsv-1core-multi-encode.png" alt="qsv 1core multi encode" /></p>

<p>ライブラリがIGPへアクセスできないようでアクセス違反起こして終了してしまうため、QSVでの同時エンコードはダメでした。</p>

<h2>ファイルサイズ比較</h2>

<p>ビットレート固定なのでそれほど違いはありませんが、ファイルサイズは以下のようになっています。</p>

<pre><code>$ ls -l
total 1261812
-rw-rw-r--. 1 ninniku ninniku 928670754 May  6  2008 big_buck_bunny_1080p_surround.avi
-rw-rw-r--. 1 ninniku ninniku 179373021 Jan 31 02:27 big_buck_bunny_qsv.mp4
-rw-rw-r--. 1 ninniku ninniku 184045287 Jan 31 02:23 big_buck_bunny_x264.mp4
</code></pre>

<p>QSVでエンコードしたほうが4MBほどファイルサイズが小さくなっていました。</p>

<h1>品質について</h1>

<p>x264とQSVの比較では目立った差異は見受けられなかったです。視力の問題かもしれませんが。</p>

<h1>まとめ</h1>

<p>動画再生時間の3分の1程度でエンコードができるQSVはLinuxでもすごい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intel QSVのH.264エンコードをLinuxで！]]></title>
    <link href="http://mzyy94.com/blog/2015/01/30/intel-qsv-on-linux/"/>
    <updated>2015-01-30T22:22:03+09:00</updated>
    <id>http://mzyy94.com/blog/2015/01/30/intel-qsv-on-linux</id>
    <content type="html"><![CDATA[<p><a href="/blog/2014/12/12/kvm-intel-hd-graphics-passthrough/">前回の記事</a>から1ヶ月以上空いてしまいました。遅ればせながらで申し訳ありません。続編です。
Intel QSVは高速にある程度の画質のエンコードできてよいです。とても。</p>

<p>今回はKVMでIntel HD Graphicsをパススルーした仮装マシン上に、SDKのインストールとカーネルモジュールのインストール、そしてffmpegでのQSVによるH.264エンコードができる環境づくりまでの手順をご紹介します。
<del>これが意外と骨が折れる作業だったので同じような思いをせぬよう、ご熟読ください。</del>（書き直す前の文章です。書き直した理由は後述。）</p>

<!-- more -->


<h1>Intel Media Server Studio (Intel Media SDK)</h1>

<p>前回の記事で紹介したIntel Media Server Studio(以下、IMSS。旧Intel Media SDK)のインストールをします。
IMSSはIntel Developer Zoneのメンバーになってから、<a href="https://software.intel.com/en-us/intel-media-server-studio">こちら</a>へアクセスすることでダウンロードできます。
メンバー登録時と同じメールアドレスを指定するとダウンロードリンクが送られてくるので、アクセスしてfor Linuxの方をダウンロードします。</p>

<p><img src="/blog/resources/images/2015/01/30/IMSS-download.png" alt="IMSS donwload page" /></p>

<p>執筆時点での最新版は2015 R3です。この2015 R3を対象にインストールを進めていきます。(12月中旬に2015 R2を対象にした記事を書き終わっていたのだけれど、公開し損ねてる間にバージョンアップがあったため最初から書き直してるなんて言えない。。)</p>

<p>IMSS 2015 R3から対応OSはCentOSとSLESの2種類のみとなったので、どちらか好きな方を選んでインストールしてください。以下にはCentOS 7での様子を載せます。</p>

<h2>Intel Media SDK Install</h2>

<p>IMSSをダウンロードし回答すると、下図のように幾つかアーカイブの入ったディレクトリが展開されます。そこにあるSDKをインストールすることでQSVを利用することができるようになります。</p>

<p><img src="/blog/resources/images/2015/01/30/IMSS-step-1.png" alt="IMSS step 1" /></p>

<p>このSDKのアーカイブを展開すると下図のように、インストール手順の書かれたPDFファイルとOSごとにディレクトリで分けられたドライバがでてきます。</p>

<p><img src="/blog/resources/images/2015/01/30/IMSS-step-2.png" alt="IMSS step 2" /></p>

<p>今回はCentOS 7なので、CentOSディレクトリに移動し、PDFに記載のインストール手順を踏むだけでいいはずなんですが、幾つか依存関係にあるパッケージが必要になります。これがなくてインストールコケまくったので下表にまとめておきます。<code>yum install</code>などでインストールしてください。</p>

<table>
<thead>
<tr>
<th style="text-align:center;">パッケージ名 </th>
<th style="text-align:left;"> 簡易説明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">mesa-dri-drivers </td>
<td style="text-align:left;"> グラフィックデバイスドライバ</td>
</tr>
<tr>
<td style="text-align:center;">redhat-lsb </td>
<td style="text-align:left;"> lsb_releaseでOS情報取得したいらしい</td>
</tr>
<tr>
<td style="text-align:center;">wget </td>
<td style="text-align:left;"> あのダウンロードするやつ</td>
</tr>
<tr>
<td style="text-align:center;">net-tools </td>
<td style="text-align:left;"> ネットワーク設定するアレ</td>
</tr>
</tbody>
</table>


<p>そしてあとは手順通りにインストールすればいいだけ。だと思ってたんですが、そのままインストールすると、ファイルやディレクトリが足りない（？）というエラーで怒られてしまいます。
見た感じインストールスクリプトのバグのようですが、一般環境向けのGeneric SDKが用意されているので、これを先にインストールしてからOS SpecificなSDKで上書きすることで、正常にインストールすることができるようです。</p>

<p>なので、SDKのディレクトリにあるGenericディレクトリに移動し、ぽつりと存在するアーカイブを展開します。</p>

<p><img src="/blog/resources/images/2015/01/30/IMSS-step-3.png" alt="IMSS step 3" /></p>

<p>展開されたファイルの中にあるシェルスクリプトを管理者権限で実行し、Generic SDKをインストールします。</p>

<p><img src="/blog/resources/images/2015/01/30/IMSS-step-4.png" alt="IMSS step 4" /></p>

<p>この作業で必要なディレクトリとファイルが作成されるので、次にOS固有のドライバとSDKをインストールします。</p>

<p>SDKのディレクトリに戻り、さらにCentOSのディレクトリに移動しファイルを確認すると、以下のようになっているはずです。</p>

<p><img src="/blog/resources/images/2015/01/30/IMSS-step-5.png" alt="IMSS step 5" /></p>

<p>　
ここではファイルの展開等は行わず、PDF記載の通りにユーザーをvideoグループに追加して、<code>/MSS</code>ディレクトリを作成してそこにファイルをコピーしてカレントディレクトリも移動し、インストール関連ファイルの入ったアーカイブを展開してでてくるSDKのインストールスクリプトを実行します。下図のninnikuはカレントユーザー名なので適当に<code>$(whoami)</code>に置換してください。</p>

<p><img src="/blog/resources/images/2015/01/30/IMSS-step-6.png" alt="IMSS step 6" /></p>

<p>SDKのインストールが成功すると、下図のようになり、再起動を促されるのでひとまず再起動します。</p>

<p><img src="/blog/resources/images/2015/01/30/IMSS-step-7.png" alt="IMSS step 7" /></p>

<p>再起動後、再度<code>/MSS</code>へ移動して、下図のようにドライバの組み込まれたカーネルをビルドします。</p>

<p><img src="/blog/resources/images/2015/01/30/IMSS-step-8.png" alt="IMSS step 8" /></p>

<p>正常に終了すると以下のようになります。</p>

<p><img src="/blog/resources/images/2015/01/30/IMSS-step-9.png" alt="IMSS step 9" /></p>

<p>指定された場所<code>./rpmbuild/RPMS/</code>に移動すると<code>x86_64</code>ディレクトリがさらにあるのでそこに移動し、ここにあるQSVドライバが組み込まれたカーネルカーネルをインストールします。しかし今回使用しているCentOS 7では、QSVドライバが組み込まれたカーネルより新しいカーネルがインストールされていたため、QSVドライバ付きカーネルのインストールを拒否されてしまいました。
古いバージョンであることを重々承知した上でインストールするため、<code>--oldpackage</code>オプションを追加してインストールし、再起動してドライバのインストールは終了です。</p>

<p><img src="/blog/resources/images/2015/01/30/IMSS-step-10.png" alt="IMSS step 10" /></p>

<p>再起動後、<code>lsmod | grep i915</code>として、以下のように幾つか該当があれば、ドライバが動作していることを確認できます。</p>

<p><img src="/blog/resources/images/2015/01/30/IMSS-step-11.png" alt="IMSS step 11" /></p>

<p>これで終わりかと思いきや、インストールスクリプトのバグなのか、ライブラリのリンク先が間違っており、実際にSDKを利用するときにリンクできずにプログラムが起動しない、などが発生してしまいます。</p>

<p>なので、下記スクリプトを実行してライブラリのパスを再設定してください。</p>

<p><code>sudo bash -c '(ldconfig -p -N | grep intel.mediasdk) || echo "/opt/intel/mediasdk/lib64" &gt;&gt; /etc/ld.so.conf.d/intel-mediasdk.conf &amp;&amp; ldconfig'</code></p>

<h1>H264_QSV codec for FFmpeg</h1>

<p>さて、IMSSのインストールができたのでSDKを利用する代表的なプログラムとして、QSVによるH.264エンコードをしましょう。</p>

<p>前回の記事で紹介した<a href="https://github.com/shenhailuanma/qsv-ffmpeg-codec">qsv_ffmpeg_codec</a>はIntel Media SDKの対応バージョンが古く、導入に手間がかかるのでIMSS 2014 R3対応版としてフォークしました。下記リポジトリに置いてあります。</p>

<p><em><a href="https://github.com/mzyy94/qsv_h264-ffmpeg">mzyy94/h264_qsv-ffmpeg</a></em></p>

<p>ここからクローンし、ディレクトリ下にある<code>./setup.sh</code>を実行して、FFmpeg-2.2ディレクトリに移動して<code>make</code>して、インストールください。</p>

<p>このコーデック、QSVによるH.264へのエンコードはしっかりとできるのですが、<strong>MPEG-TSファイルのエンコードはエラーになります</strong>。原因は、TSの仕組みゆえの、ライブラリの関数<code>MFXVideoENCODE_EncodeFrameAsync</code>に渡される引数によるものというところまではわかったのですが、修正にはほぼ全ての処理を書き換えないといけない手間がかかるので、MPEG-TSから一度RAWファイルを抽出し、パイプ等を使ってQSVコーデックに渡してエンコードしてください。</p>

<p>実行方法の例としては、
<code>ffmpeg -i in.avi -acodec copy -vcodec h264_qsv -b:v 2000k -y -sar 16:9 -s 1280x720 -r 30000/1001 -bufsize 20000k -maxrate 25000k out.mp4</code>
のようにHDサイズにリサイズして変換することができます。</p>

<p>せっかくなのでベンチマークとして、<a href="http://www.bigbuckbunny.org">Big Buck Bunny</a>をエンコードしようと思ったのですが、残念ながら執筆中にダウンロードが終わらなかったのでまたの機会に追記する形で公開しようと思います。</p>

<h1>まとめ</h1>

<p>LinuxでもQSVできる。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KVMでQSVするためIntel HD Graphicsパススルーするー]]></title>
    <link href="http://mzyy94.com/blog/2014/12/12/kvm-intel-hd-graphics-passthrough/"/>
    <updated>2014-12-12T23:59:49+09:00</updated>
    <id>http://mzyy94.com/blog/2014/12/12/kvm-intel-hd-graphics-passthrough</id>
    <content type="html"><![CDATA[<p>この記事は<a href="http://qiita.com/advent-calendar/2014/linux">Linux Advent Calendar 2014</a> 12日目の記事です。</p>

<p>12月も中頃となり寒い日が続きますね。みなさん体調はいかがでしょうか。</p>

<p>先日の<a href="/blog/2014/12/10/kotatsu-heating/">こたつを温める実験</a>で十分な熱を得られることを知ってしまい、つい調子に乗って動画のエンコードをこたつの中でやってしまって、40℃超の高温になるという経験を得るなど、新しい発見のある毎日です。</p>

<p>こたつ温め実験で使った録画サーバーはCPUがIntel Celeron 847はとても貧弱で、動画をH.264にエンコードしようものなら30分のアニメで8時間かかってしまうほどです。
なんとか短時間で動画エンコードできないかと悩んでいたところ、Intel QuickSync Video(以下QSV、詳細は後述)がLinuxもサポートされていることを思い出し、LinuxでQSVエンコードをしてみようと思い立ちました。</p>

<p>QSVを利用できるベアメタルマシンは我が家に2台あり、より新しいものはCPUにXeon E3v3を搭載しています。
このマシンではKVMで仮想マシンを複数立ち上げていて、カーネルコンパイルなどのCIを回したり、クロスコンパイル環境を構築しているものです。
今回はそのマシンに録画用仮想マシンを立て、録画に必要なUSBデバイスとPCI ExpressのレーンとQSVエンコードのためにIntel HD Graphicsのパススルーを試みる記録の第1章となります。</p>

<!-- more -->


<h1>Intel QuickSync Video</h1>

<p><a href="http://www.intel.co.jp/content/www/jp/ja/architecture-and-technology/quick-sync-video/quick-sync-video-general.html">IntelのQSV公式サイト</a>に情報が載っていますが簡単にまとめます。</p>

<p>Intel Quick Sync Videoとは、Sandy Bridge世代のCore iシリーズのIntel CPUに搭載されているIntel HD Graphicsによる、動画のハードウェアエンコード・デコード技術のことです。
対象となるコーデックはH.264とH.262のみですが、エンコードに関してはソフトウェアで行うものよりもQSVを利用したものの方が圧倒的に高速（ただし品質は低下する模様）です。</p>

<p>QSVをオープンソースな動画エンコードソフトウェアで利用する動きは近頃活発であり、有名どころとしては<a href="https://handbrake.fr">Handbrake</a>が最新版である<a href="https://handbrake.fr/news.php?article=27">バージョン0.10.0でQSVエンコードをサポート</a>し始めました。
<a href="http://www.videolan.org">VLC</a>も<a href="http://www.videolan.org/vlc/releases/2.1.0.html">バージョン2.10からQSVエンコードをサポート</a>しています。</p>

<p>ただ、これらのオープンソースソフトウェア(OSS)によって、QSVによるH.264エンコード高速化の恩恵を受けられるのは、両者ともいまのところWindows版のみとなっています。</p>

<h1>QSV on Linux</h1>

<p>Windows向けにしかOSSのQSVエンコーダーがないからって、なにもLinuxでQSVでエンコードできないわけではないのです。
ffmpegのエンコードコーデックとして、LinuxでもQSVエンコードができる<a href="https://github.com/shenhailuanma/qsv-ffmpeg-codec">qsv-ffmpeg-codec</a>なるものがあるのです。
これを利用するには、Intel Media SDKを導入する必要がありますが、これによってOSSでのQSVエンコードがLinuxでもできるのです。</p>

<h1>Intel Media SDK</h1>

<p>Intel HD GraphicsをLinuxで利用するためにはSDKが必要となります。そのSDKがこれ、Intel Media SDKです。これは現在、<a href="https://software.intel.com/en-us/intel-media-server-studio">Intel(r) Medoa Server Studio 2015</a>(以下IMSS)に含まれる形で提供されています。IMSS 2015 R2ではUbuntuとSUSE Linuxがサポートされています。</p>

<h1>Intel HD Graphics pass-through</h1>

<p>いろいろなシステムの説明を終えたのでここからが本題です。
KVMでIntel HD Graphicsをpass-throughする方法を手順を追って説明していきます。</p>

<p>仮想マシンでのPCIデバイスのパススルーはよく行われており、XenにおいてはGPUパススルーによって<a href="http://www.slideshare.net/zgock/203o">家庭内VDIサーバーを作る</a>というような例があります。</p>

<p><a href="http://www.slideshare.net/zgock/203o">http://www.slideshare.net/zgock/203o</a>&#8220;>http://www.slideshare.net/zgock/203o&#8221;>http://www.slideshare.net/zgock/203o</a></a></p>

<p>XenによるPCIパススルーの記事はたくさん見つかるものの、KVMによるPCIパススルーに関するものは少なく、ましてやCPU内臓GPUのパススルーは皆無と言ってもいいほどです。
これは、KVMにおいてPCIパススルーをするにはIntel VT-dテクノロジーが必要なので、ユーザーが限られてしまうのも影響しているかもしれません。</p>

<p>KVMでPCIパススルーするための手がかりを<code>make menuconfig</code>で調べたところ、次の2つのオプションを有効化することでIntel HD GraphicsをKVMにパススルーできそうだということがわかりました。</p>

<p><img src="/blog/resources/images/2014/12/12/Intel-IOMMU-option.png" alt="Intel IOMMU" />
<img src="/blog/resources/images/2014/12/12/VFIO-option.png" alt="Intel VFIO" /></p>

<p>Intel IOMMUはIntel VT-dの機能をカーネルで有効にするものです。
また、VFIOはIOMMUによるデバイスへのアクセスを提供するものです。</p>

<p>これらを有効にしてコンパイル &amp;&amp; インストールしカーネルをKVMでPCIデバイスパススルーできるようにします。</p>

<p>その次はqemuの起動オプションです。
まず、ベアメタルマシン上ではどのようにIntel HD Graphicsが認識されているのかを調べます。</p>

<p><img src="/blog/resources/images/2014/12/12/Intel-HD-Graphics-Host.png" alt="Intel HD Graphics host" /></p>

<p>バス00:02.0にIntel HD Graphicsが認識されています。</p>

<p>このバス 00:02.0をPCIデバイスとしてパススルーするため、kvmの起動オプションに<code>-device vfio-pci,host=00:02.0,id=hostpci0,bus=ich9-pcie-port-1,addr=0x0,x-vga=on -machine type=q35</code>を追加します。</p>

<p><strong> !&#8211; 追記(2015/1/30) &#8211; </strong></p>

<p>このとき、CPUタイプのオプションを<code>-cpu Haswell,kvm=off,+x2apic</code>とすることを忘れないでください。</p>

<p><strong> !&#8211; 追記ここまで &#8211; </strong></p>

<p>すると、ゲストLinuxにしっかりとIntel HD Graphicsが渡されていることがわかります。</p>

<p><img src="/blog/resources/images/2014/12/12/Intel-HD-Graphics-Guest.png" alt="Intel HD Graphics guest" /></p>

<h1>Intel Media SDK Install</h1>

<p>この先の記事が長くなってしまったのでIMSSのインストール以降は後ほど別記事に書きます。。</p>

<h1>まとめ</h1>

<p>KVMでもPCIパススルーして幸せになろう！</p>

<p>明日はmasami256さんです。</p>
]]></content>
  </entry>
  
</feed>
